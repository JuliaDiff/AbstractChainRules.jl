<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Writing Good Rules · ChainRules</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit">ChainRules</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="FAQ.html">FAQ</a></li><li><a class="tocitem" href="config.html">Rule configurations and calling back into AD</a></li><li><a class="tocitem" href="opting_out_of_rules.html">Opting out of rules</a></li><li class="is-active"><a class="tocitem" href="writing_good_rules.html">Writing Good Rules</a><ul class="internal"><li><a class="tocitem" href="#Code-Style"><span>Code Style</span></a></li><li><a class="tocitem" href="#Use-ZeroTangent()-as-the-return-value"><span>Use <code>ZeroTangent()</code> as the return value</span></a></li><li><a class="tocitem" href="#Use-Thunks-appropriately"><span>Use <code>Thunk</code>s appropriately</span></a></li><li><a class="tocitem" href="#Ensure-you-remain-in-the-primal&#39;s-subspace-(i.e.-use-ProjectTo-appropriately)"><span>Ensure you remain in the primal&#39;s subspace (i.e. use <code>ProjectTo</code> appropriately)</span></a></li><li><a class="tocitem" href="#Structs:-constructors-and-functors"><span>Structs: constructors and functors</span></a></li><li><a class="tocitem" href="#Ensure-your-pullback-can-accept-the-right-types"><span>Ensure your pullback can accept the right types</span></a></li><li><a class="tocitem" href="#Use-@not_implemented-appropriately"><span>Use <code>@not_implemented</code> appropriately</span></a></li><li><a class="tocitem" href="#Use-rule-definition-tools"><span>Use rule definition tools</span></a></li><li><a class="tocitem" href="#Be-careful-about-pullback-closures-calling-other-methods-of-themselves"><span>Be careful about pullback closures calling other methods of themselves</span></a></li><li><a class="tocitem" href="#Write-tests"><span>Write tests</span></a></li><li><a class="tocitem" href="#CAS-systems-are-your-friends."><span>CAS systems are your friends.</span></a></li><li><a class="tocitem" href="#Which-functions-need-rules?"><span>Which functions need rules?</span></a></li></ul></li><li><a class="tocitem" href="complex.html">Complex Numbers</a></li><li><a class="tocitem" href="arrays.html">Deriving Array Rules</a></li><li><a class="tocitem" href="debug_mode.html">Debug Mode</a></li><li><a class="tocitem" href="gradient_accumulation.html">Gradient Accumulation</a></li><li><a class="tocitem" href="use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="converting_zygoterules.html">Converting ZygoteRules</a></li><li><a class="tocitem" href="tips_for_packages.html">Tips for making packages work with AD</a></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="design/many_differentials.html">Many Differential Types</a></li></ul></li><li><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="writing_good_rules.html">Writing Good Rules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="writing_good_rules.html">Writing Good Rules</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/writing_good_rules.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="On-writing-good-rrule-/-frule-methods"><a class="docs-heading-anchor" href="#On-writing-good-rrule-/-frule-methods">On writing good <code>rrule</code> / <code>frule</code> methods</a><a id="On-writing-good-rrule-/-frule-methods-1"></a><a class="docs-heading-anchor-permalink" href="#On-writing-good-rrule-/-frule-methods" title="Permalink"></a></h1><h2 id="Code-Style"><a class="docs-heading-anchor" href="#Code-Style">Code Style</a><a id="Code-Style-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Style" title="Permalink"></a></h2><p>Use named local functions for the <code>pullback</code> in an <code>rrule</code>.</p><pre><code class="language-julia"># good:
function rrule(::typeof(foo), x)
    Y = foo(x)
    function foo_pullback(Ȳ)
        return NoTangent(), bar(Ȳ)
    end
    return Y, foo_pullback
end
#== output
julia&gt; rrule(foo, 2)
(4, var&quot;#foo_pullback#11&quot;())
==#

# bad:
function rrule(::typeof(foo), x)
    return foo(x), x̄ -&gt; (NoTangent(), bar(x̄))
end
#== output:
julia&gt; rrule(foo, 2)
(4, var&quot;##9#10&quot;())
==#</code></pre><p>While this is more verbose, it ensures that if an error is thrown during the <code>pullback</code> the <a href="https://docs.julialang.org/en/v1/base/base/#Base.gensym"><code>gensym</code></a> name of the local function will include the name you gave it. This makes it a lot simpler to debug from the stacktrace.</p><h2 id="Use-ZeroTangent()-as-the-return-value"><a class="docs-heading-anchor" href="#Use-ZeroTangent()-as-the-return-value">Use <code>ZeroTangent()</code> as the return value</a><a id="Use-ZeroTangent()-as-the-return-value-1"></a><a class="docs-heading-anchor-permalink" href="#Use-ZeroTangent()-as-the-return-value" title="Permalink"></a></h2><p>The <code>ZeroTangent()</code> object exists as an alternative to directly returning <code>0</code> or <code>zeros(n)</code>. It allows more optimal computation when chaining pullbacks/pushforwards, to avoid work. They should be used where possible.</p><p>However, sometimes for performance reasons this is not ideal. Especially, if it is to replace a scalar, and is in a type-unstable way. It causes problems if mapping over such pullbacks/pushforwards. This woull be solved once <a href="https://github.com/JuliaLang/julia/issues/38241">JuliaLang/julia#38241</a> has been addressed.</p><h2 id="Use-Thunks-appropriately"><a class="docs-heading-anchor" href="#Use-Thunks-appropriately">Use <code>Thunk</code>s appropriately</a><a id="Use-Thunks-appropriately-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Thunks-appropriately" title="Permalink"></a></h2><p>If work is only required for one of the returned differentials, then it should be wrapped in a <code>@thunk</code> (potentially using a <code>begin</code>-<code>end</code> block).</p><p>If there are multiple return values, their computation should almost always be wrapped in a <code>@thunk</code>.</p><p>Do <em>not</em> wrap <em>variables</em> in a <code>@thunk</code>; wrap the <em>computations</em> that fill those variables in <code>@thunk</code>:</p><pre><code class="language-julia"># good:
∂A = @thunk(foo(x))
return ∂A

# bad:
∂A = foo(x)
return @thunk(∂A)</code></pre><p>In the bad example <code>foo(x)</code> gets computed eagerly, and all that the thunk is doing is wrapping the already calculated result in a function that returns it.</p><p>Do not use <code>@thunk</code> if this would be equal or more work than actually evaluating the expression itself. Examples being:</p><ul><li>The expression being a constant</li><li>The expression is merely wrapping something in a <code>struct</code>, such as <code>Adjoint(x)</code> or <code>Diagonal(x)</code></li><li>The expression being itself a <code>thunk</code></li><li>The expression being from another <code>rrule</code> or <code>frule</code>; it would be <code>@thunk</code>ed if required by the defining rule already.</li><li>There is only one derivative being returned, so from the fact that the user called <code>frule</code>/<code>rrule</code> they clearly will want to use that one.</li></ul><h2 id="Ensure-you-remain-in-the-primal&#39;s-subspace-(i.e.-use-ProjectTo-appropriately)"><a class="docs-heading-anchor" href="#Ensure-you-remain-in-the-primal&#39;s-subspace-(i.e.-use-ProjectTo-appropriately)">Ensure you remain in the primal&#39;s subspace (i.e. use <code>ProjectTo</code> appropriately)</a><a id="Ensure-you-remain-in-the-primal&#39;s-subspace-(i.e.-use-ProjectTo-appropriately)-1"></a><a class="docs-heading-anchor-permalink" href="#Ensure-you-remain-in-the-primal&#39;s-subspace-(i.e.-use-ProjectTo-appropriately)" title="Permalink"></a></h2><p>Rules with abstractly-typed arguments may return incorrect answers when called with certain concrete types. A classic example is the matrix-matrix multiplication rule, a naive definition of which follows:</p><pre><code class="language-julia">function rrule(::typeof(*), A::AbstractMatrix, B::AbstractMatrix)
    function times_pullback(ȳ)
        dA = ȳ * B&#39;
        dB = A&#39; * ȳ
        return NoTangent(), dA, dB
    end
    return A * B, times_pullback 
end</code></pre><p>When computing <code>*(A, B)</code>, where <code>A isa Diagonal</code> and <code>B isa Matrix</code>, the output will be a <code>Matrix</code>. As a result, <code>ȳ</code> in the pullback will be a <code>Matrix</code>, and consequently <code>dA</code> for a <code>A isa Diagonal</code> will be a <code>Matrix</code>, which is wrong. Not only is it the wrong type, but it can contain non-zeros off the diagonal, which is not possible, it is outside of the subspace. While a specialised rules can indeed be written for the <code>Diagonal</code> case, there are many other types and we don&#39;t want to be forced to write a rule for each of them. Instead, <code>project_A = ProjectTo(A)</code> can be used (outside the pullback) to extract an object that knows how to project onto the type of <code>A</code> (e.g. also knows the size of the array). This object can be called with a tangent <code>ȳ * B&#39;</code>, by doing <code>project_A(ȳ * B&#39;)</code>, to project it on the tangent space of <code>A</code>. The correct rule then looks like</p><pre><code class="language-julia">function rrule(::typeof(*), A::AbstractMatrix, B::AbstractMatrix)
    project_A = ProjectTo(A)
    project_B = ProjectTo(B)
    function times_pullback(ȳ)
        dA = ȳ * B&#39;
        dB = A&#39; * ȳ
        return NoTangent(), project_A(dA), project_B(dB)
    end
    return A * B, times_pullback
end</code></pre><div class="admonition is-info"><header class="admonition-header">It is often good to `@thunk` your projections</header><div class="admonition-body"><p>The above example is potentially a good place for using a <a href="api.html#ChainRulesCore.@thunk-Tuple{Any}"><code>@thunk</code></a>. This is not required, but can in some cases be more computationally efficient, see <a href="writing_good_rules.html#Use-Thunks-appropriately">Use <code>Thunk</code>s appropriately</a>. When combining thunks and projections, <code>@thunk()</code> must be the outermost call.</p><p>A more optimized implementation of the matrix-matrix multiplication example would have</p><pre><code class="language-julia">times_pullback(ȳ) = NoTangent(), @thunk(project_A(ȳ * B&#39;)), @thunk(project_B(A&#39; * ȳ))</code></pre><p>within the <code>rrule</code>. This defers both the evaluation of the product rule and the projection until(/if) the tangent gets used.</p></div></div><h2 id="Structs:-constructors-and-functors"><a class="docs-heading-anchor" href="#Structs:-constructors-and-functors">Structs: constructors and functors</a><a id="Structs:-constructors-and-functors-1"></a><a class="docs-heading-anchor-permalink" href="#Structs:-constructors-and-functors" title="Permalink"></a></h2><p>To define an <code>frule</code> or <code>rrule</code> for a <em>function</em> <code>foo</code> we dispatch on the type of <code>foo</code>, which is <code>typeof(foo)</code>. For example, the <code>rrule</code> signature would be like:</p><pre><code class="language-julia">function rrule(::typeof(foo), args...; kwargs...)
    ...
    return y, foo_pullback
end</code></pre><p>For a struct <code>Bar</code>,</p><pre><code class="language-julia">struct Bar
    a::Float64
end

(bar::Bar)(x, y) = return bar.a + x + y # functor (i.e. callable object, overloading the call action)</code></pre><p>we can define an <code>frule</code>/<code>rrule</code> for the <code>Bar</code> constructor(s), as well as any <code>Bar</code> <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">functors</a>.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>To define an <code>rrule</code> for a constructor for a  <em>type</em> <code>Bar</code> we need to be careful to dispatch only on <code>Type{Bar}</code>. For example, the <code>rrule</code> signature for a <code>Bar</code> constructor would be like:</p><pre><code class="language-julia">function ChainRulesCore.rrule(::Type{Bar}, a)
    Bar_pullback(Δbar) = NoTangent(), Δbar.a
    return Bar(a), Bar_pullback
end</code></pre><p>Use <code>Type{&lt;:Bar}</code> (with the <code>&lt;:</code>) for non-concrete types, such that the <code>rrule</code> is defined for all subtypes. In particular, be careful not to use <code>typeof(Bar)</code> here. Because <code>typeof(Bar)</code> is <code>DataType</code>, using this to define an <code>rrule</code>/<code>frule</code> will define an <code>rrule</code>/<code>frule</code> for all constructors.</p><p>You can check which to use with <code>Core.Typeof</code>:</p><pre><code class="language-julia">julia&gt; function foo end
foo (generic function with 0 methods)

julia&gt; typeof(foo)
typeof(foo)

julia&gt; Core.Typeof(foob)
typeof(foo)

julia&gt; typeof(Bar)
DataType

julia&gt; Core.Typeof(Bar)
Type{Bar}

julia&gt; abstract type AbstractT end

julia&gt; typeof(AbstractT)
DataType

julia&gt; Core.Typeof(AbstractT)
Type{AbstractT}</code></pre><h3 id="Functors-(callable-objects)"><a class="docs-heading-anchor" href="#Functors-(callable-objects)">Functors (callable objects)</a><a id="Functors-(callable-objects)-1"></a><a class="docs-heading-anchor-permalink" href="#Functors-(callable-objects)" title="Permalink"></a></h3><p>In contrast to defining a rule for a constructor, it is possible to define rules for calling an instance of an object. In that case, use <code>bar::Bar</code>, i.e.</p><pre><code class="language-julia">function ChainRulesCore.rrule(bar::Bar, x, y)
    # Notice the first return is not `NoTangent()`
    Bar_pullback(Δy) = Tangent{Bar}(;a=Δy), Δy, Δy
    return bar(x, y), Bar_pullback
end</code></pre><p>to define the rules.</p><h2 id="Ensure-your-pullback-can-accept-the-right-types"><a class="docs-heading-anchor" href="#Ensure-your-pullback-can-accept-the-right-types">Ensure your pullback can accept the right types</a><a id="Ensure-your-pullback-can-accept-the-right-types-1"></a><a class="docs-heading-anchor-permalink" href="#Ensure-your-pullback-can-accept-the-right-types" title="Permalink"></a></h2><p>As a rule the number of types you need to accept in a pullback is theoretically unlimitted, but practically highly constrained to be in line with the primal return type. The three kinds of inputs you will practically need to accept one or more of: <em>natural tangents</em>, <em>structural tangents</em>, and <em>thunks</em>. You do not in general have to handle <code>AbstractZero</code>s as the AD system will not call the pullback if the input is a zero, since the output will also be. Some more background information on these types can be found in <a href="design/many_differentials.html#manytypes">the design notes</a>. In many cases all these tangents can be treated the same: tangent types overload a bunch of linear-operators, and the majority of functions used inside a pullback are linear operators. If you find linear operators from Base/stdlibs that are not supported, consider opening an issue or a PR on the <a href="https://github.com/JuliaDiff/ChainRulesCore.jl/">ChainRulesCore.jl repo</a>.</p><h3 id="Natural-tangents"><a class="docs-heading-anchor" href="#Natural-tangents">Natural tangents</a><a id="Natural-tangents-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-tangents" title="Permalink"></a></h3><p>Natural tangent types are the types you might feel the tangent should be, to represent a small change in the primal value. For example, if the primal is a <code>Float32</code>, the natural tangent is also a <code>Float32</code>. Slightly more complex, for a <code>ComplexF64</code> the natural tangent is again also a <code>ComplexF64</code>, we almost never want to use the structural tangent <code>Tangent{ComplexF64}(re=..., im=...)</code> which is defined. For other cases, this gets a little more complicated, see below. These are a purely human notion, they are the types the user wants to use because they make the math easy. There is currently no formal definition of what constitutes a natural tangent, but there are a few heuristics. For example, if a primal type <code>P</code> overloads subtraction (<code>-(::P,::P)</code>) then that generally returns a natural tangent type for <code>P</code>; but this is not required to be defined and sometimes it is defined poorly.</p><p>Common cases for types that represent a <a href="https://en.wikipedia.org/wiki/Vector_space">vector-space</a> (e.g. <code>Float64</code>, <code>Array{Float64}</code>) is that the natural tangent type is the same as the primal type. However, this is not always the case. For example for a <a href="https://github.com/JuliaStats/PDMats.jl"><code>PDiagMat</code></a> a natural tangent is <code>Diagonal</code> since there is no requirement that a positive definite diagonal matrix has a positive definite tangent. Another example is for a <code>DateTime</code>, any <code>Period</code> subtype, such as <code>Millisecond</code> or <code>Nanosecond</code> is a natural differential. There are often many different natural tangent types for a given primal type. However, they are generally closely related and duck-type the same. For example, for most <code>AbstractArray</code> subtypes, most other <code>AbstractArray</code>s (of right size and element type) can be considered as natural tangent types.</p><p>Not all types have natural tangent types. For example there is no natural differential for a <code>Tuple</code>. It is not a <code>Tuple</code> since that doesn&#39;t have any method for <code>+</code>. Similar is true for many <code>struct</code>s. For those cases there is only a structural differential.</p><h3 id="Structural-tangents"><a class="docs-heading-anchor" href="#Structural-tangents">Structural tangents</a><a id="Structural-tangents-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-tangents" title="Permalink"></a></h3><p>Structural tangents are tangent types that shadow the structure of the primal type. They are represented by the <a href="api.html#ChainRulesCore.Tangent"><code>Tangent</code></a> type. They can represent any composite type, such as a tuple, or a structure (or a <code>NamedTuple</code>) etc.</p><div class="admonition is-info"><header class="admonition-header">Do I have to support the structural tangents as well?</header><div class="admonition-body"><p>Technically, you might not actually have to write rules to accept structural tangents; if the AD system never has to decompose down to the level of <code>getfield</code>. This is common for types that don&#39;t support user <code>getfield</code>/<code>getproperty</code> access, and that have a lot of rules for the ways they are accessed (such cases include some <code>AbstractArray</code> subtypes). You really should support it just in case; especially if the primal type in question is not restricted to a well-tested concrete type. But if it is causing struggles, then you can leave it off til someone complains.</p></div></div><h3 id="Thunks"><a class="docs-heading-anchor" href="#Thunks">Thunks</a><a id="Thunks-1"></a><a class="docs-heading-anchor-permalink" href="#Thunks" title="Permalink"></a></h3><p>A thunk (either a <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a>, or a <a href="api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a>), represents a delayed computation. They can be thought of as a wrapper of the value the computation returns. In this sense they wrap either a natural or structural tangent.</p><div class="admonition is-warning"><header class="admonition-header">You should support AbstractThunk inputs even if you don&#39;t use thunks</header><div class="admonition-body"><p>Unfortunately the AD sytems do not know which rules support thunks and which do not.  So all rules have to; at least if they want to play nicely with arbitrary AD systems.  Luckily it is not hard: much of the time they will duck-type as the object they wrap.  If not, then just add a <a href="api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a> after the start of your pullback.  (Even when they do duck-type, if they are used multiple times then unthunking at the start will prevent them from being recomputed.)  If you are using <a href="api.html#ChainRulesCore.@thunk-Tuple{Any}"><code>@thunk</code></a> and the input is only needed for one of them then the <code>unthunk</code> should be in that one.  If not, and you have a bunch of pullbacks you might like to write a little helper <code>unthunking(f) = x̄ -&gt; f(unthunk(x̄))</code> that you can wrap your pullback function in before returning it from the <code>rrule</code>.  Yes, this is a bit of boiler-plate, and it is unfortunate.  Sadly, it is needed because if the AD wants to benefit it can&#39;t get that benifit unless things are not unthunked unnecessarily.  Which eventually allows them in some cases to never be unthunked at all.  There are two ways common things are never unthunked.  One is if the unthunking happens inside a <code>@thunk</code> which is never unthunked itself because it is the tangent for a primal input that never has it&#39;s tangent queried.  The second is if they are not unthunked because the rule does not need to know what is inside: consider the pullback for <code>identity</code>: <code>x̄ -&gt; (NoTangent(), x̄)</code>.</p></div></div><h2 id="Use-@not_implemented-appropriately"><a class="docs-heading-anchor" href="#Use-@not_implemented-appropriately">Use <code>@not_implemented</code> appropriately</a><a id="Use-@not_implemented-appropriately-1"></a><a class="docs-heading-anchor-permalink" href="#Use-@not_implemented-appropriately" title="Permalink"></a></h2><p>You can use <a href="api.html#ChainRulesCore.@not_implemented-Tuple{Any}"><code>@not_implemented</code></a> to mark missing differentials. This is helpful if the function has multiple inputs or outputs, and you have worked out analytically and implemented some but not all differentials.</p><p>It is recommended to include a link to a GitHub issue about the missing differential in the debugging information:</p><pre><code class="language-julia">@not_implemented(
    &quot;&quot;&quot;
    derivatives of Bessel functions with respect to the order are not implemented:
    https://github.com/JuliaMath/SpecialFunctions.jl/issues/160
    &quot;&quot;&quot;
)</code></pre><p>Do not use <code>@not_implemented</code> if the differential does not exist mathematically (use <code>NoTangent()</code> instead).</p><p>Note: <a href="https://github.com/JuliaDiff/ChainRulesTestUtils.jl">ChainRulesTestUtils.jl</a> marks <code>@not_implemented</code> differentials as &quot;test broken&quot;.</p><h2 id="Use-rule-definition-tools"><a class="docs-heading-anchor" href="#Use-rule-definition-tools">Use rule definition tools</a><a id="Use-rule-definition-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Use-rule-definition-tools" title="Permalink"></a></h2><p>Rule definition tools can help you write more <code>frule</code>s and the <code>rrule</code>s with less lines of code.</p><h3 id="[@non_differentiable](@ref)"><a class="docs-heading-anchor" href="#[@non_differentiable](@ref)"><a href="api.html#ChainRulesCore.@non_differentiable-Tuple{Any}"><code>@non_differentiable</code></a></a><a id="[@non_differentiable](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[@non_differentiable](@ref)" title="Permalink"></a></h3><p>For non-differentiable functions the <a href="api.html#ChainRulesCore.@non_differentiable-Tuple{Any}"><code>@non_differentiable</code></a> macro can be used. For example, instead of manually defining the <code>frule</code> and the <code>rrule</code> for string concatenation <code>*(String..)</code>, the macro call</p><pre><code class="language-julia">@non_differentiable *(String...)</code></pre><p>defines the following <code>frule</code> and <code>rrule</code> automatically</p><pre><code class="language-julia">function ChainRulesCore.frule(var&quot;##_#1600&quot;, ::Core.Typeof(*), String::Any...; kwargs...)
    return (*(String...; kwargs...), NoTangent())
end
function ChainRulesCore.rrule(::Core.Typeof(*), String::Any...; kwargs...)
    return (*(String...; kwargs...), function var&quot;*_pullback&quot;(_)
        (ZeroTangent(), ntuple((_-&gt;NoTangent()), 0 + length(String))...)
    end)
end</code></pre><p>Note that the types of arguments are propagated to the <code>frule</code> and <code>rrule</code> definitions. This is needed in case the function differentiable for some but not for other types of arguments. For example <code>*(1, 2, 3)</code> is differentiable, and is not defined with the macro call above.</p><h3 id="[@scalar_rule](@ref)"><a class="docs-heading-anchor" href="#[@scalar_rule](@ref)"><a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>@scalar_rule</code></a></a><a id="[@scalar_rule](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[@scalar_rule](@ref)" title="Permalink"></a></h3><p>For functions involving only scalars, i.e. subtypes of <code>Number</code> (no <code>struct</code>s, <code>String</code>s...), both the <code>frule</code> and the <code>rrule</code> can be defined using a single <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>@scalar_rule</code></a> macro call. </p><p>Note that the function does not have to be <span>$\mathbb{R} \rightarrow \mathbb{R}$</span>. In fact, any number of scalar arguments is supported, as is returning a tuple of scalars.</p><p>See docstrings for the comprehensive usage instructions.</p><h2 id="Be-careful-about-pullback-closures-calling-other-methods-of-themselves"><a class="docs-heading-anchor" href="#Be-careful-about-pullback-closures-calling-other-methods-of-themselves">Be careful about pullback closures calling other methods of themselves</a><a id="Be-careful-about-pullback-closures-calling-other-methods-of-themselves-1"></a><a class="docs-heading-anchor-permalink" href="#Be-careful-about-pullback-closures-calling-other-methods-of-themselves" title="Permalink"></a></h2><p>Due to <a href="https://github.com/JuliaLang/julia/issues/40990">JuliaLang/Julia#40990</a>, a closure calling another (or the same) method of itself often comes out uninferable (and thus effectively type-unstable). This can be avoided by moving the pullback definition outside the function, so that it is no longer a closure. For example:</p><pre><code class="language-julia">double_it(x::AbstractArray) = 2 .* x

function ChainRulesCore.rrule(::typeof(double_it), x)
    double_it_pullback(ȳ::AbstractArray) = (NoTangent(), 2 .* ȳ)
    double_it_pullback(ȳ::AbstractThunk) = double_it_pullback(unthunk(ȳ))
    return double_it(x), double_it_pullback
end</code></pre><p>Ends up infering a return type of <code>Any</code></p><pre><code class="language-julia">julia&gt; _, pullback = rrule(double_it, [2.0, 3.0])
([4.0, 6.0], var&quot;#double_it_pullback#8&quot;(Core.Box(var&quot;#double_it_pullback#8&quot;(#= circular reference @-2 =#))))

julia&gt; @code_warntype pullback(@thunk([10.0, 10.0]))
Variables
  #self#::var&quot;#double_it_pullback#8&quot;
  ȳ::Core.Const(Thunk(var&quot;#9#10&quot;()))
  double_it_pullback::Union{}

Body::Any
1 ─ %1 = Core.getfield(#self#, :double_it_pullback)::Core.Box
│   %2 = Core.isdefined(%1, :contents)::Bool
└──      goto #3 if not %2
2 ─      goto #4
3 ─      Core.NewvarNode(:(double_it_pullback))
└──      double_it_pullback
4 ┄ %7 = Core.getfield(%1, :contents)::Any
│   %8 = Main.unthunk(ȳ)::Vector{Float64}
│   %9 = (%7)(%8)::Any
└──      return %9</code></pre><p>This can be solved by moving the pullbacks outside the function so they are not closures, and thus to not run into this upstream issue. In this case that is fairly simple, since this example doesn&#39;t close over anything (if it did then would need a closure calling an outside function that calls itself. See <a href="https://github.com/JuliaDiff/ChainRules.jl/blob/773039a2dc0a1938f61cf26012b1223c942bc18f/src/rulesets/LinearAlgebra/structured.jl#L107-L116">this example</a>.).</p><pre><code class="language-julia">_double_it_pullback(ȳ::AbstractArray) = (NoTangent(), 2 .* ȳ)
_double_it_pullback(ȳ::AbstractThunk) = _double_it_pullback(unthunk(ȳ))

function ChainRulesCore.rrule(::typeof(double_it), x)
    return double_it(x), _double_it_pullback
end</code></pre><p>This infers just fine:</p><pre><code class="language-julia">julia&gt; _, pullback = rrule(double_it, [2.0, 3.0])
([4.0, 6.0], _double_it_pullback)

julia&gt; @code_warntype pullback(@thunk([10.0, 10.0]))
Variables
  #self#::Core.Const(_double_it_pullback)
  ȳ::Core.Const(Thunk(var&quot;#7#8&quot;()))

Body::Tuple{NoTangent, Vector{Float64}}
1 ─ %1 = Main.unthunk(ȳ)::Vector{Float64}
│   %2 = Main._double_it_pullback(%1)::Core.PartialStruct(Tuple{NoTangent, Vector{Float64}}, Any[Core.Const(NoTangent()), Vector{Float64}])
└──      return %2</code></pre><p>Though in this particular case, it can also be solved by taking advantage of duck-typing and just writing one method. Thus avoiding the call that confuses the compiler. <code>Thunk</code>s duck-type as the type they wrap in most cases: including broadcast multiplication.</p><pre><code class="language-julia">function ChainRulesCore.rrule(::typeof(double_it), x)
    double_it_pullback(ȳ) = (NoTangent(), 2 .* ȳ)
    return double_it(x), double_it_pullback
end</code></pre><p>This infers perfectly.</p><h2 id="Write-tests"><a class="docs-heading-anchor" href="#Write-tests">Write tests</a><a id="Write-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Write-tests" title="Permalink"></a></h2><p><a href="https://github.com/JuliaDiff/ChainRulesTestUtils.jl">ChainRulesTestUtils.jl</a> provides tools for writing tests based on <a href="https://github.com/JuliaDiff/FiniteDifferences.jl">FiniteDifferences.jl</a>. Take a look at the documentation or the existing <a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules.jl</a> tests to see how to write the tests.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Don&#39;t use analytical derivations for derivatives in the tests. Those are what you use to define the rules, and so cannot be confidently used in the test. If you misread/misunderstood them, then your tests/implementation will have the same mistake. Use finite differencing methods instead, as they are based on the primal computation.</p></div></div><h2 id="CAS-systems-are-your-friends."><a class="docs-heading-anchor" href="#CAS-systems-are-your-friends.">CAS systems are your friends.</a><a id="CAS-systems-are-your-friends.-1"></a><a class="docs-heading-anchor-permalink" href="#CAS-systems-are-your-friends." title="Permalink"></a></h2><p>It is very easy to check gradients or derivatives with a computer algebra system (CAS) like <a href="https://www.wolframalpha.com/input/?i=gradient+atan2%28x%2Cy%29">WolframAlpha</a>.</p><h2 id="Which-functions-need-rules?"><a class="docs-heading-anchor" href="#Which-functions-need-rules?">Which functions need rules?</a><a id="Which-functions-need-rules?-1"></a><a class="docs-heading-anchor-permalink" href="#Which-functions-need-rules?" title="Permalink"></a></h2><p>In principle, a perfect AD system only needs rules for basic operations and can infer the rules for more complicated functions automatically. In practice, performance needs to be considered as well.</p><p>Some functions use <code>ccall</code> internally, for example <a href="https://github.com/JuliaLang/julia/blob/v1.5.3/base/math.jl#L886"><code>^</code></a>. These functions cannot be differentiated through by AD systems, and need custom rules.</p><p>Other functions can in principle be differentiated through by an AD system, but there exists a mathematical insight that can dramatically improve the computation of the derivative. An example is numerical integration, where writing a rule implementing the <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus">fundamental theorem of calculus</a> removes the need to perform AD through numerical integration.</p><p>Furthermore, AD systems make different trade-offs in performance due to their design. This means that a certain rule will help one AD system, but not improve (and also not harm) another. Below, we list some patterns relevant for the <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a> AD system.</p><p>Rules for functions which mutate its arguments, e.g. <code>sort!</code>, should not be written at the moment. While technically they are supported, they would break <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a> such that <a href="https://github.com/JuliaDiff/ChainRulesCore.jl/issues/242">it would sometimes quietly return the wrong answer</a>. This may be resolved in the future by <a href="https://github.com/JuliaDiff/ChainRulesCore.jl/issues/270">allowing AD systems to opt-in or opt-out of certain types of rules</a>.</p><h3 id="Patterns-that-need-rules-in-[Zygote.jl](https://github.com/FluxML/Zygote.jl)"><a class="docs-heading-anchor" href="#Patterns-that-need-rules-in-[Zygote.jl](https://github.com/FluxML/Zygote.jl)">Patterns that need rules in <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a></a><a id="Patterns-that-need-rules-in-[Zygote.jl](https://github.com/FluxML/Zygote.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#Patterns-that-need-rules-in-[Zygote.jl](https://github.com/FluxML/Zygote.jl)" title="Permalink"></a></h3><p>There are a few classes of functions that Zygote cannot differentiate through. Custom rules will need to be written for these to make AD work.</p><p>Other patterns can be AD&#39;ed through, but the backward pass performance can be greatly improved by writing a rule.</p><h4 id="Functions-which-mutate-arrays"><a class="docs-heading-anchor" href="#Functions-which-mutate-arrays">Functions which mutate arrays</a><a id="Functions-which-mutate-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-which-mutate-arrays" title="Permalink"></a></h4><p>For example,</p><pre><code class="language-julia">function addone!(array)
    array .+= 1
    return sum(array)
end</code></pre><p>complains that</p><pre><code class="language-julia">julia&gt; using Zygote
julia&gt; gradient(addone!, a)
ERROR: Mutating arrays is not supported</code></pre><p>However, upon adding the <code>rrule</code> (restart the REPL after calling <code>gradient</code>)</p><pre><code class="language-julia">function ChainRules.rrule(::typeof(addone!), a)
    y = addone!(a)
    function addone!_pullback(ȳ)
        return NoTangent(), ones(length(a))
    end
    return y, addone!_pullback
end</code></pre><p>the gradient can be evaluated:</p><pre><code class="language-julia">julia&gt; gradient(addone!, a)
([1.0, 1.0, 1.0],)</code></pre><div class="admonition is-info"><header class="admonition-header">Why restarting REPL after calling `gradient`?</header><div class="admonition-body"><p>When <code>gradient</code> is called in <code>Zygote</code> for a function with no <code>rrule</code> defined, a backward pass for the function call is generated and cached. When <code>gradient</code> is called for the second time on the same function signature, the backward pass is reused without checking whether an an <code>rrule</code> has been defined between the two calls to <code>gradient</code>.</p><p>If an <code>rrule</code> is defined before the first call to <code>gradient</code> it should register the rule and use it, but that prevents comparing what happens before and after the <code>rrule</code> is defined. To compare both versions with and without an <code>rrule</code> in the REPL simultaneously, define a function <code>f(x) = &lt;body&gt;</code> (no <code>rrule</code>), another function <code>f_cr(x) = f(x)</code>, and an <code>rrule</code> for <code>f_cr</code>.</p></div></div><h4 id="Exception-handling"><a class="docs-heading-anchor" href="#Exception-handling">Exception handling</a><a id="Exception-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Exception-handling" title="Permalink"></a></h4><p>Zygote does not support differentiating through <code>try</code>/<code>catch</code> statements. For example, differentiating through</p><pre><code class="language-julia">function exception(x)
    try
        return x^2
    catch e
        println(&quot;could not square input&quot;)
        throw(e)
    end
end</code></pre><p>does not work</p><pre><code class="language-julia">julia&gt; gradient(exception, 3.0)
ERROR: Compiling Tuple{typeof(exception),Int64}: try/catch is not supported.</code></pre><p>without an <code>rrule</code> defined (restart the REPL after calling <code>gradient</code>)</p><pre><code class="language-julia">function ChainRulesCore.rrule(::typeof(exception), x)
    y = exception(x)
    function exception_pullback(ȳ)
        return NoTangent(), 2*x
    end
    return y, exception_pullback
end</code></pre><pre><code class="language-julia">julia&gt; gradient(exception, 3.0)
(6.0,)</code></pre><h4 id="Loops"><a class="docs-heading-anchor" href="#Loops">Loops</a><a id="Loops-1"></a><a class="docs-heading-anchor-permalink" href="#Loops" title="Permalink"></a></h4><p>Julia runs loops fast. Unfortunately Zygote differentiates through loops slowly. So, for example, computing the mean squared error by using a loop</p><pre><code class="language-julia">function mse(y, ŷ)
    N = length(y)
    s = 0.0
    for i in 1:N
        s +=  (y[i] - ŷ[i])^2.0
    end
    return s/N
end</code></pre><p>takes a lot longer to AD through</p><pre><code class="language-julia">julia&gt; y = rand(30)
julia&gt; ŷ = rand(30)
julia&gt; @btime gradient(mse, $y, $ŷ)
  38.180 μs (993 allocations: 65.00 KiB)</code></pre><p>than if we supply an <code>rrule</code>, (restart the REPL after calling <code>gradient</code>)</p><pre><code class="language-julia">function ChainRules.rrule(::typeof(mse), x, x̂)
    output = mse(x, x̂)
    function mse_pullback(ȳ)
        N = length(x)
        g = (2 ./ N) .* (x .- x̂) .* ȳ
        return NoTangent(), g, -g
    end
    return output, mse_pullback
end</code></pre><p>which is much faster</p><pre><code class="language-julia">julia&gt; @btime gradient(mse, $y, $ŷ)
  143.697 ns (2 allocations: 672 bytes)</code></pre><h4 id="Inplace-accumulation"><a class="docs-heading-anchor" href="#Inplace-accumulation">Inplace accumulation</a><a id="Inplace-accumulation-1"></a><a class="docs-heading-anchor-permalink" href="#Inplace-accumulation" title="Permalink"></a></h4><p>Inplace accumulation of gradients is slow in <code>Zygote</code>. The issue, demonstrated in the folowing example, is that the gradient of <code>getindex</code> allocates an array of zeros with a single non-zero element. </p><pre><code class="language-julia">function sum3(array)
    x = array[1]
    y = array[2]
    z = array[3]
    return x+y+z
end</code></pre><pre><code class="language-julia">julia&gt; @btime gradient(sum3, rand(30))
  424.510 ns (9 allocations: 2.06 KiB)</code></pre><p>Computing the gradient with only a single array allocation using an <code>rrule</code> (restart the REPL after calling <code>gradient</code>)</p><pre><code class="language-julia">function ChainRulesCore.rrule(::typeof(sum3), a)
    y = sum3(a)
    function sum3_pullback(ȳ)
        grad = zeros(length(a))
        grad[1:3] .+= ȳ
        return NoTangent(), grad
    end
    return y, sum3_pullback
end</code></pre><p>turns out to be significantly faster </p><pre><code class="language-julia">julia&gt; @btime gradient(sum3, rand(30))
  192.818 ns (3 allocations: 784 bytes)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="opting_out_of_rules.html">« Opting out of rules</a><a class="docs-footer-nextpage" href="complex.html">Complex Numbers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 27 September 2021 15:16">Monday 27 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
