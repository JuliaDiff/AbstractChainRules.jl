<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ChainRules</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit">ChainRules</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="FAQ.html">FAQ</a></li><li><a class="tocitem" href="config.html">Rule configurations and calling back into AD</a></li><li><a class="tocitem" href="opting_out_of_rules.html">Opting out of rules</a></li><li><a class="tocitem" href="writing_good_rules.html">Writing Good Rules</a></li><li><a class="tocitem" href="complex.html">Complex Numbers</a></li><li><a class="tocitem" href="arrays.html">Deriving Array Rules</a></li><li><a class="tocitem" href="debug_mode.html">Debug Mode</a></li><li><a class="tocitem" href="gradient_accumulation.html">Gradient Accumulation</a></li><li><a class="tocitem" href="use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="converting_zygoterules.html">Converting ZygoteRules</a></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="design/many_differentials.html">Many Differential Types</a></li></ul></li><li class="is-active"><a class="tocitem" href="api.html">API</a><ul class="internal"><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Rule-Definition-Tools"><span>Rule Definition Tools</span></a></li><li><a class="tocitem" href="#Differentials"><span>Differentials</span></a></li><li><a class="tocitem" href="#Accumulation"><span>Accumulation</span></a></li><li><a class="tocitem" href="#RuleConfig"><span>RuleConfig</span></a></li><li><a class="tocitem" href="#ProjectTo"><span>ProjectTo</span></a></li><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}" href="#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>ChainRulesCore.frule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">frule([::RuleConfig,] (Δf, Δx...), f, x...)</code></pre><p>Expressing the output of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, ΔΩ)</code></pre><p>The second return value is the differential w.r.t. the output.</p><p>If no method matching <code>frule((Δf, Δx...), f, x...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; dself = NoTangent();

julia&gt; x = rand()
0.8236475079774124

julia&gt; sinx, Δsinx = frule((dself, 1), sin, x)
(0.7336293678134624, 0.6795498147167869)

julia&gt; sinx == sin(x)
true

julia&gt; Δsinx == cos(x)
true</code></pre><p>Unary input, binary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; sincosx, Δsincosx = frule((dself, 1), sincos, x);

julia&gt; sincosx == sincos(x)
true

julia&gt; Δsincosx[1] == cos(x)
true

julia&gt; Δsincosx[2] == -sin(x)
true</code></pre><p>Note that techically speaking julia does not have multiple output functions, just functions that return a single output that is iterable, like a <code>Tuple</code>. So this is actually a <a href="api.html#ChainRulesCore.Tangent"><code>Tangent</code></a>:</p><pre><code class="language-julia-repl">julia&gt; Δsincosx
Tangent{Tuple{Float64, Float64}}(0.6795498147167869, -0.7336293678134624)</code></pre><p>The optional <a href="api.html#ChainRulesCore.RuleConfig"><code>RuleConfig</code></a> option allows specifying frules only for AD systems that support given features. If not needed, then it can be omitted and the <code>frule</code> without it will be hit as a fallback. This is the case for most rules.</p><p>See also: <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>@scalar_rule</code></a>, <a href="api.html#ChainRulesCore.RuleConfig"><code>RuleConfig</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/rules.jl#L1-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}" href="#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>ChainRulesCore.rrule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rrule([::RuleConfig,] f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (Ω̄₁, Ω̄₂, ...) -&gt; (s̄elf, x̄₁, x̄₂, ...))</code></pre><p>Where the second return value is the the propagation rule or pullback. It takes in differentials corresponding to the outputs (<code>x̄₁, x̄₂, ...</code>), and <code>s̄elf</code>, the internal values of the function itself (for closures)</p><p>If no method matching <code>rrule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x = rand();

julia&gt; sinx, sin_pullback = rrule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; sin_pullback(1) == (NoTangent(), cos(x))
true</code></pre><p>binary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x, y = rand(2);

julia&gt; hypotxy, hypot_pullback = rrule(hypot, x, y);

julia&gt; hypotxy == hypot(x, y)
true

julia&gt; hypot_pullback(1) == (NoTangent(), (x / hypot(x, y)), (y / hypot(x, y)))
true</code></pre><p>The optional <a href="api.html#ChainRulesCore.RuleConfig"><code>RuleConfig</code></a> option allows specifying rrules only for AD systems that support given features. If not needed, then it can be omitted and the <code>rrule</code> without it will be hit as a fallback. This is the case for most rules.</p><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>@scalar_rule</code></a>, <a href="api.html#ChainRulesCore.RuleConfig"><code>RuleConfig</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/rules.jl#L81-L130">source</a></section></article><h2 id="Rule-Definition-Tools"><a class="docs-heading-anchor" href="#Rule-Definition-Tools">Rule Definition Tools</a><a id="Rule-Definition-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Definition-Tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.@non_differentiable-Tuple{Any}" href="#ChainRulesCore.@non_differentiable-Tuple{Any}"><code>ChainRulesCore.@non_differentiable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@non_differentiable(signature_expression)</code></pre><p>A helper to make it easier to declare that a method is not differentiable. This is a short-hand for defining an <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a> and <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a> that return <a href="api.html#ChainRulesCore.NoTangent"><code>NoTangent()</code></a> for all partials (even for the function <code>s̄elf</code>-partial itself)</p><p>Keyword arguments should not be included.</p><pre><code class="language-julia-repl">julia&gt; @non_differentiable Base.:(==)(a, b)

julia&gt; _, pullback = rrule(==, 2.0, 3.0);

julia&gt; pullback(1.0)
(NoTangent(), NoTangent(), NoTangent())</code></pre><p>You can place type-constraints in the signature:</p><pre><code class="language-julia-repl">julia&gt; @non_differentiable Base.length(xs::Union{Number, Array})

julia&gt; frule((ZeroTangent(), 1), length, [2.0, 3.0])
(2, NoTangent())</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This helper macro covers only the simple common cases. It does not support <code>where</code>-clauses. For these you can declare the <code>rrule</code> and <code>frule</code> directly</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/rule_definition_tools.jl#L282-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.@opt_out-Tuple{Any}" href="#ChainRulesCore.@opt_out-Tuple{Any}"><code>ChainRulesCore.@opt_out</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@opt_out frule([config], _, f, args...)
@opt_out rrule([config], f, args...)</code></pre><p>This allows you to opt-out of an <code>frule</code> or an <code>rrule</code> by providing a more specific method, that says to use the AD system to differentiate it.</p><p>For example, consider some function <code>foo(x::AbtractArray)</code>. In general, you know an efficient and generic way to implement its <code>rrule</code>. You do so, (likely making use of <a href="api.html#ChainRulesCore.ProjectTo"><code>ProjectTo</code></a>). But it actually turns out that for some <code>FancyArray</code> type it is better to let the AD do its thing.</p><p>Then you would write something like:</p><pre><code class="language-julia">function rrule(::typeof(foo), x::AbstractArray)
    foo_pullback(ȳ) = ...
    return foo(x), foo_pullback
end

@opt_out rrule(::typeof(foo), ::FancyArray)</code></pre><p>This will generate an <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a> that returns <code>nothing</code>, and will also add a similar entry to <a href="api.html#ChainRulesCore.no_rrule"><code>ChainRulesCore.no_rrule</code></a>.</p><p>Similar applies for <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a> and <a href="api.html#ChainRulesCore.no_frule"><code>ChainRulesCore.no_frule</code></a></p><p>For more information see the <a href="opting_out_of_rules.html#opt_out">documentation on opting out of rules</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/rule_definition_tools.jl#L404-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}" href="#ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>ChainRulesCore.@scalar_rule</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@scalar_rule(f(x₁, x₂, ...),
             @setup(statement₁, statement₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>A convenience macro that generates simple scalar forward or reverse rules using the provided partial derivatives. Specifically, generates the corresponding methods for <code>frule</code> and <code>rrule</code>:</p><pre><code class="language-none">function ChainRulesCore.frule((NoTangent(), Δx₁, Δx₂, ...), ::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (
            (∂f₁_∂x₁ * Δx₁ + ∂f₁_∂x₂ * Δx₂ + ...),
            (∂f₂_∂x₁ * Δx₁ + ∂f₂_∂x₂ * Δx₂ + ...),
            ...
        )
end

function ChainRulesCore.rrule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, ((ΔΩ₁, ΔΩ₂, ...)) -&gt; (
            NoTangent(),
            ∂f₁_∂x₁ * ΔΩ₁ + ∂f₂_∂x₁ * ΔΩ₂ + ...),
            ∂f₁_∂x₂ * ΔΩ₁ + ∂f₂_∂x₂ * ΔΩ₂ + ...),
            ...
        )
end</code></pre><p>If no type constraints in <code>f(x₁, x₂, ...)</code> within the call to <code>@scalar_rule</code> are provided, each parameter in the resulting <code>frule</code>/<code>rrule</code> definition is given a type constraint of <code>Number</code>. Constraints may also be explicitly be provided to override the <code>Number</code> constraint, e.g. <code>f(x₁::Complex, x₂)</code>, which will constrain <code>x₁</code> to <code>Complex</code> and <code>x₂</code> to <code>Number</code>.</p><p>At present this does not support defining for closures/functors. Thus in reverse-mode, the first returned partial, representing the derivative with respect to the function itself, is always <code>NoTangent()</code>. And in forward-mode, the first input to the returned propagator is always ignored.</p><p>The result of <code>f(x₁, x₂, ...)</code> is automatically bound to <code>Ω</code>. This allows the primal result to be conveniently referenced (as <code>Ω</code>) within the derivative/setup expressions.</p><p>This macro assumes complex functions are holomorphic. In general, for non-holomorphic functions, the <code>frule</code> and <code>rrule</code> must be defined manually.</p><p>If the derivative is one, (e.g. for identity functions) <code>true</code> can be used as the most general multiplicative identity.</p><p>The <code>@setup</code> argument can be elided if no setup code is need. In other words:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>is equivalent to:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             @setup(nothing),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>For examples, see ChainRules&#39; <code>rulesets</code> directory.</p><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/rule_definition_tools.jl#L11-L84">source</a></section></article><h2 id="Differentials"><a class="docs-heading-anchor" href="#Differentials">Differentials</a><a id="Differentials-1"></a><a class="docs-heading-anchor-permalink" href="#Differentials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.AbstractZero" href="#ChainRulesCore.AbstractZero"><code>ChainRulesCore.AbstractZero</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractZero &lt;: AbstractTangent</code></pre><p>Supertype for zero-like differentials—i.e., differentials that act like zero when added or multiplied to other values. If an AD system encounters a propagator that takes as input only subtypes of <code>AbstractZero</code>, then it can stop performing AD operations. All propagators are linear functions, and thus the final result will be zero.</p><p>All <code>AbstractZero</code> subtypes are singleton types. There are two of them: <a href="api.html#ChainRulesCore.ZeroTangent"><code>ZeroTangent()</code></a> and <a href="api.html#ChainRulesCore.NoTangent"><code>NoTangent()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/abstract_zero.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.NoTangent" href="#ChainRulesCore.NoTangent"><code>ChainRulesCore.NoTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoTangent() &lt;: AbstractZero</code></pre><p>This differential indicates that the derivative does not exist. It is the differential for primal types that are not differentiable, such as integers or booleans (when they are not being used to represent floating-point values). The only valid way to perturb such values is to not change them at all. As a consequence, <code>NoTangent</code> is functionally identical to <code>ZeroTangent()</code>, but it provides additional semantic information.</p><p>Adding this differential to a primal is generally wrong: gradient-based methods cannot be used to optimize over discrete variables. An optimization package making use of this might want to check for such a case.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This does not indicate that the derivative is not implemented, but rather that mathematically it is not defined.</p></div></div><p>This mostly shows up as the derivative with respect to dimension, index, or size arguments.</p><pre><code class="language-none">    function rrule(fill, x, len::Int)
        y = fill(x, len)
        fill_pullback(ȳ) = (NoTangent(), @thunk(sum(Ȳ)), NoTangent())
        return y, fill_pullback
    end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/abstract_zero.jl#L52-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.ZeroTangent" href="#ChainRulesCore.ZeroTangent"><code>ChainRulesCore.ZeroTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ZeroTangent() &lt;: AbstractZero</code></pre><p>The additive identity for differentials. This is basically the same as <code>0</code>. A derivative of <code>ZeroTangent()</code> does not propagate through the primal function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/abstract_zero.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.Tangent" href="#ChainRulesCore.Tangent"><code>ChainRulesCore.Tangent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Tangent{P, T} &lt;: AbstractTangent</code></pre><p>This type represents the differential for a <code>struct</code>/<code>NamedTuple</code>, or <code>Tuple</code>. <code>P</code> is the the corresponding primal type that this is a differential for.</p><p><code>Tangent{P}</code> should have fields (technically properties), that match to a subset of the fields of the primal type; and each should be a differential type matching to the primal type of that field. Fields of the P that are not present in the Tangent are treated as <code>Zero</code>.</p><p><code>T</code> is an implementation detail representing the backing data structure. For Tuple it will be a Tuple, and for everything else it will be a <code>NamedTuple</code>. It should not be passed in by user.</p><p>For <code>Tangent</code>s of <code>Tuple</code>s, <code>iterate</code> and <code>getindex</code> are overloaded to behave similarly to for a tuple. For <code>Tangent</code>s of <code>struct</code>s, <code>getproperty</code> is overloaded to allow for accessing values via <code>comp.fieldname</code>. Any fields not explictly present in the <code>Tangent</code> are treated as being set to <code>ZeroTangent()</code>. To make a <code>Tangent</code> have all the fields of the primal the <a href="api.html#ChainRulesCore.canonicalize-Union{Tuple{Tangent{P, var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(NamedTuple{L, T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where {P, L}"><code>canonicalize</code></a> function is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/composite.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.canonicalize-Union{Tuple{Tangent{P, var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(NamedTuple{L, T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where {P, L}" href="#ChainRulesCore.canonicalize-Union{Tuple{Tangent{P, var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(NamedTuple{L, T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where {P, L}"><code>ChainRulesCore.canonicalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">canonicalize(comp::Tangent{P}) -&gt; Tangent{P}</code></pre><p>Return the canonical <code>Tangent</code> for the primal type <code>P</code>. The property names of the returned <code>Tangent</code> match the field names of the primal, and all fields of <code>P</code> not present in the input <code>comp</code> are explictly set to <code>ZeroTangent()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/composite.jl#L156-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.InplaceableThunk" href="#ChainRulesCore.InplaceableThunk"><code>ChainRulesCore.InplaceableThunk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InplaceableThunk(add!::Function, val::Thunk)</code></pre><p>A wrapper for a <code>Thunk</code>, that allows it to define an inplace <code>add!</code> function.</p><p><code>add!</code> should be defined such that: <code>ithunk.add!(Δ) = Δ .+= ithunk.val</code> but it should do this more efficently than simply doing this directly. (Otherwise one can just use a normal <code>Thunk</code>).</p><p>Most operations on an <code>InplaceableThunk</code> treat it just like a normal <code>Thunk</code>; and destroy its inplacability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/thunks.jl#L196-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.Thunk" href="#ChainRulesCore.Thunk"><code>ChainRulesCore.Thunk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Thunk(()-&gt;v)</code></pre><p>A thunk is a deferred computation. It wraps a zero argument closure that when invoked returns a differential. <code>@thunk(v)</code> is a macro that expands into <code>Thunk(()-&gt;v)</code>.</p><p>To evaluate the wrapped closure, call <a href="api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a> which is a no-op when the argument is not a <code>Thunk</code>.</p><pre><code class="language-julia-repl">julia&gt; t = @thunk(3)
Thunk(var&quot;#4#5&quot;())

julia&gt; unthunk(t)
3</code></pre><p><strong>When to <code>@thunk</code>?</strong></p><p>When writing <code>rrule</code>s (and to a lesser exent <code>frule</code>s), it is important to <code>@thunk</code> appropriately. Propagation rules that return multiple derivatives may not have all deriviatives used.  By <code>@thunk</code>ing the work required for each derivative, they then compute only what is needed.</p><p><strong>How do thunks prevent work?</strong></p><p>If we have <code>res = pullback(...) = @thunk(f(x)), @thunk(g(x))</code> then if we did <code>dx + res[1]</code> then only <code>f(x)</code> would be evaluated, not <code>g(x)</code>. Also if we did <code>ZeroTangent() * res[1]</code> then the result would be <code>ZeroTangent()</code> and <code>f(x)</code> would not be evaluated.</p><p><strong>So why not thunk everything?</strong></p><p><code>@thunk</code> creates a closure over the expression, which (effectively) creates a <code>struct</code> with a field for each variable used in the expression, and call overloaded.</p><p>Do not use <code>@thunk</code> if this would be equal or more work than actually evaluating the expression itself. This is commonly the case for scalar operators.</p><p>For more details see the manual section <a href="http://www.juliadiff.org/ChainRulesCore.jl/dev/writing_good_rules.html#Use-Thunks-appropriately-1">on using thunks effectively</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/thunks.jl#L148-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.unthunk-Tuple{Any}" href="#ChainRulesCore.unthunk-Tuple{Any}"><code>ChainRulesCore.unthunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unthunk(x)</code></pre><p>On <code>AbstractThunk</code>s this removes 1 layer of thunking. On any other type, it is the identity operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/thunks.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.@thunk-Tuple{Any}" href="#ChainRulesCore.@thunk-Tuple{Any}"><code>ChainRulesCore.@thunk</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@thunk expr</code></pre><p>Define a <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> wrapping the <code>expr</code>, to lazily defer its evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/thunks.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.@not_implemented-Tuple{Any}" href="#ChainRulesCore.@not_implemented-Tuple{Any}"><code>ChainRulesCore.@not_implemented</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@not_implemented(info)</code></pre><p>Create a differential that indicates that the derivative is not implemented.</p><p>The <code>info</code> should be useful information about the missing differential for debugging.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This macro should be used only if the automatic differentiation would error otherwise. It is mostly useful if the function has multiple inputs or outputs, and one has worked out analytically and implemented some but not all differentials.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is good practice to include a link to a GitHub issue about the missing differential in the debugging information.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/notimplemented.jl#L1-L16">source</a></section></article><h2 id="Accumulation"><a class="docs-heading-anchor" href="#Accumulation">Accumulation</a><a id="Accumulation-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.add!!" href="#ChainRulesCore.add!!"><code>ChainRulesCore.add!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add!!(x, y)</code></pre><p>Returns <code>x+y</code>, potentially mutating <code>x</code> in-place to hold this value. This avoids allocations when <code>x</code> can be mutated in this way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/accumulation.jl#L1-L6">source</a></section><section><div><pre><code class="language-none">add!!(x, t::InplacableThunk)</code></pre><p>The specialization of <code>add!!</code> for <a href="api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a> promises to only call <code>t.add!</code> on <code>x</code> if <code>x</code> is suitably mutable; otherwise it will be out of place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/accumulation.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.is_inplaceable_destination" href="#ChainRulesCore.is_inplaceable_destination"><code>ChainRulesCore.is_inplaceable_destination</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_inplaceable_destination(x) -&gt; Bool</code></pre><p>Returns true if <code>x</code> is suitable for for storing inplace accumulation of gradients. For arrays this boils down <code>x .= y</code> if will work to mutate <code>x</code>, if <code>y</code> is an appropriate differential. Wrapper array types do not need to overload this if they overload <code>Base.parent</code>, and are <code>is_inplaceable_destination</code> if and only if their parent array is. Other types should overload this, as it defaults to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/accumulation.jl#L38-L47">source</a></section></article><h2 id="RuleConfig"><a class="docs-heading-anchor" href="#RuleConfig">RuleConfig</a><a id="RuleConfig-1"></a><a class="docs-heading-anchor-permalink" href="#RuleConfig" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.HasForwardsMode" href="#ChainRulesCore.HasForwardsMode"><code>ChainRulesCore.HasForwardsMode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>HasForwardsMode</p><p>This trait indicates that a <code>RuleConfig{&gt;:HasForwardsMode}</code> can perform forward mode AD. If it is set then <a href="api.html#ChainRulesCore.frule_via_ad"><code>frule_via_ad</code></a> must be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/config.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.HasReverseMode" href="#ChainRulesCore.HasReverseMode"><code>ChainRulesCore.HasReverseMode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>HasReverseMode</p><p>This trait indicates that a <code>RuleConfig{&gt;:HasReverseMode}</code> can perform reverse mode AD. If it is set then <a href="api.html#ChainRulesCore.rrule_via_ad"><code>rrule_via_ad</code></a> must be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/config.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.NoForwardsMode" href="#ChainRulesCore.NoForwardsMode"><code>ChainRulesCore.NoForwardsMode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NoForwardsMode</p><p>This is the complement to <a href="api.html#ChainRulesCore.HasForwardsMode"><code>HasForwardsMode</code></a>. To avoid ambiguities [<code>RuleConfig</code>]s that do not support performing forwards mode AD should be <code>RuleConfig{&gt;:NoForwardsMode}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/config.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.NoReverseMode" href="#ChainRulesCore.NoReverseMode"><code>ChainRulesCore.NoReverseMode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NoReverseMode</p><p>This is the complement to <a href="api.html#ChainRulesCore.HasReverseMode"><code>HasReverseMode</code></a>. To avoid ambiguities [<code>RuleConfig</code>]s that do not support performing reverse mode AD should be <code>RuleConfig{&gt;:NoReverseMode}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/config.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.RuleConfig" href="#ChainRulesCore.RuleConfig"><code>ChainRulesCore.RuleConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RuleConfig{T}</code></pre><p>The configuration for what rules to use. <code>T</code>: <strong>traits</strong>. This should be a <code>Union</code> of all special traits needed for rules to be allowed to be defined for your AD. If nothing special this should be set to <code>Union{}</code>.</p><p><strong>AD authors</strong> should define a subtype of <code>RuleConfig</code> to use when calling <code>frule</code>/<code>rrule</code>.</p><p><strong>Rule authors</strong> can dispatch on this config when defining rules. For example:</p><pre><code class="language-julia"># only define rrule for `pop!` on AD systems where mutation is supported.
rrule(::RuleConfig{&gt;:SupportsMutation}, typeof(pop!), ::Vector) = ...

# this definition of map is for any AD that defines a forwards mode
rrule(conf::RuleConfig{&gt;:HasForwardsMode}, typeof(map), ::Vector) = ...

# this definition of map is for any AD that only defines a reverse mode.
# It is not as good as the rrule that can be used if the AD defines a forward-mode as well.
rrule(conf::RuleConfig{&gt;:Union{NoForwardsMode, HasReverseMode}}, typeof(map), ::Vector) = ...</code></pre><p>For more details see <a href="config.html#config">rule configurations and calling back into AD</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/config.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.frule_via_ad" href="#ChainRulesCore.frule_via_ad"><code>ChainRulesCore.frule_via_ad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">frule_via_ad(::RuleConfig{&gt;:HasForwardsMode}, ȧrgs, f, args...; kwargs...)</code></pre><p>This function has the same API as <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a>, but operates via performing forwards mode automatic differentiation. Any <code>RuleConfig</code> subtype that supports the <a href="api.html#ChainRulesCore.HasForwardsMode"><code>HasForwardsMode</code></a> special feature must provide an implementation of it.</p><p>See also: <a href="api.html#ChainRulesCore.rrule_via_ad"><code>rrule_via_ad</code></a>, <a href="api.html#ChainRulesCore.RuleConfig"><code>RuleConfig</code></a> and the documentation on <a href="config.html#config">rule configurations and calling back into AD</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/config.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.rrule_via_ad" href="#ChainRulesCore.rrule_via_ad"><code>ChainRulesCore.rrule_via_ad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rrule_via_ad(::RuleConfig{&gt;:HasReverseMode}, f, args...; kwargs...)</code></pre><p>This function has the same API as <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a>, but operates via performing reverse mode automatic differentiation. Any <code>RuleConfig</code> subtype that supports the <a href="api.html#ChainRulesCore.HasReverseMode"><code>HasReverseMode</code></a> special feature must provide an implementation of it.</p><p>See also: <a href="api.html#ChainRulesCore.frule_via_ad"><code>frule_via_ad</code></a>, <a href="api.html#ChainRulesCore.RuleConfig"><code>RuleConfig</code></a> and the documentation on <a href="config.html#config">rule configurations and calling back into AD</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/config.jl#L81-L91">source</a></section></article><h2 id="ProjectTo"><a class="docs-heading-anchor" href="#ProjectTo">ProjectTo</a><a id="ProjectTo-1"></a><a class="docs-heading-anchor-permalink" href="#ProjectTo" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.ProjectTo" href="#ChainRulesCore.ProjectTo"><code>ChainRulesCore.ProjectTo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">(p::ProjectTo{T})(dx)</code></pre><p>Projects the differential <code>dx</code> onto a specific tangent space.</p><p>The type <code>T</code> is meant to encode the largest acceptable space, so usually this enforces <code>p(dx)::T</code>. But some subspaces which aren&#39;t subtypes of <code>T</code> may be allowed, and in particular <code>dx::AbstractZero</code> always passes through.</p><p>Usually <code>T</code> is the &quot;outermost&quot; part of the type, and <code>p</code> stores additional properties such as projectors for each constituent field. Arrays have either one projector <code>p.element</code> expressing the element type for an array of numbers, or else an array of projectors <code>p.elements</code>. These properties can be supplied as keyword arguments on construction, <code>p = ProjectTo{T}(; field=data, element=Projector(x))</code>. For each <code>T</code> in use, corresponding methods should be written for <code>ProjectTo{T}(dx)</code> with nonzero <code>dx</code>.</p><p>When called on <code>dx::Thunk</code>, the projection is inserted into the thunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/projection.jl#L1-L19">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.AbstractTangent" href="#ChainRulesCore.AbstractTangent"><code>ChainRulesCore.AbstractTangent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The subtypes of <code>AbstractTangent</code> define a custom &quot;algebra&quot; for chain rule evaluation that attempts to factor various features like complex derivative support, broadcast fusion, zero-elision, etc. into nicely separated parts.</p><p>In general a differential type is the type of a derivative of a value. The type of the value is for contrast called the primal type. Differential types correspond to primal types, although the relation is not one-to-one. Subtypes of  <code>AbstractTangent</code> are not the only differential types. In fact for the most common primal types, such as <code>Real</code> or <code>AbstractArray{Real}</code> the the differential type is the same as the primal type.</p><p>In a circular definition: the most important property of a differential is that it should be able to be added (by defining <code>+</code>) to another differential of the same primal type. That allows for gradients to be accumulated.</p><p>It generally also should be able to be added to a primal to give back another primal, as this facilitates gradient descent.</p><p>All subtypes of <code>AbstractTangent</code> implement the following operations:</p><ul><li><code>+(a, b)</code>: linearly combine differential <code>a</code> and differential <code>b</code></li><li><code>*(a, b)</code>: multiply the differential <code>b</code> by the scaling factor <code>a</code></li><li><code>Base.zero(x) = ZeroTangent()</code>: a zero.</li></ul><p>Further, they often implement other linear operators, such as <code>conj</code>, <code>adjoint</code>, <code>dot</code>. Pullbacks/pushforwards are linear operators, and their inputs are often <code>AbstractTangent</code> subtypes. Pullbacks/pushforwards in-turn call other linear operators on those inputs. Thus it is desirable to have all common linear operators work on <code>AbstractTangent</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/differentials/abstract_differential.jl#L5-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.debug_mode" href="#ChainRulesCore.debug_mode"><code>ChainRulesCore.debug_mode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">debug_mode() -&gt; Bool</code></pre><p>Determines if ChainRulesCore is in <code>debug_mode</code>. Defaults to <code>false</code>, but if the user redefines it to return <code>true</code> then extra information will be shown when errors occur.</p><p>Enable via:</p><pre><code class="language-none">ChainRulesCore.debug_mode() = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/debug_mode.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.no_rrule" href="#ChainRulesCore.no_rrule"><code>ChainRulesCore.no_rrule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">no_rrule</code></pre><p>This is an piece of infastructure supporting opting out of <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a>. It follows the signature for <code>rrule</code> exactly. A collection of type-tuples is stored in its method-table. If something has this defined, it means that it must having a must also have a <code>rrule</code>,  defined that returns <code>nothing</code>.</p><p>!!! warning &quot;do not overload no<em>rrule directly     It is fine and intended to query the method table of `no</em>rrule<code>.     It is not safe to add to that directly, as corresponding changes also need to be made to</code>rrule<code>.     The [</code>@opt<em>out<code>](@ref) macro does both these things, and so should almost always be used     rather than defining a method of</code>no</em>rrule` directly.</p><p><strong>Mechanics</strong></p><p>note: when the text below says methods <code>==</code> it actually means: <code>parameters(m.sig)[2:end]</code> (i.e. the signature type tuple) rather than the method object <code>m</code> itself.</p><p>To decide if should opt-out using this mechanism.</p><ul><li>find the most specific method of <code>rrule</code> and <code>no_rule</code> e.g with <code>Base.which</code></li><li>if the method of <code>no_rrule</code> <code>==</code> the method of <code>rrule</code>, then should opt-out</li></ul><p>To just ignore the fact that rules can be opted-out from, and that some rules thus return <code>nothing</code>, then filter the list of methods of <code>rrule</code> to remove those that are <code>==</code> to ones that occur in the method table of <code>no_rrule</code>.</p><p>Note also when doing this you must still also handle falling back from rule with config, to rule without config.</p><p>On the other-hand if your AD can work with <code>rrule</code>s that return <code>nothing</code>, then it is simpler to just use that mechanism for opting out; and you don&#39;t need to worry about this at all.</p><p>For more information see the <a href="opting_out_of_rules.html#opt_out">documentation on opting out of rules</a></p><p>See also <a href="api.html#ChainRulesCore.no_frule"><code>ChainRulesCore.no_frule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/rules.jl#L184-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.no_frule" href="#ChainRulesCore.no_frule"><code>ChainRulesCore.no_frule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">no_frule</code></pre><p>This is an piece of infastructure supporting opting out of <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a>. It follows the signature for <code>frule</code> exactly. A collection of type-tuples is stored in its method-table. If something has this defined, it means that it must having a must also have a <code>frule</code>,  defined that returns <code>nothing</code>.</p><p>!!! warning &quot;do not overload no<em>frule directly     It is fine and intended to query the method table of `no</em>frule<code>.     It is not safe to add to that directly, as corresponding changes also need to be made to</code>frule<code>.     The [</code>@opt<em>out<code>](@ref) macro does both these things, and so should almost always be used     rather than defining a method of</code>no</em>frule` directly.</p><p><strong>Mechanics</strong></p><p>note: when the text below says methods <code>==</code> it actually means: <code>parameters(m.sig)[2:end]</code> (i.e. the signature type tuple) rather than the method object <code>m</code> itself.</p><p>To decide if should opt-out using this mechanism.</p><ul><li>find the most specific method of <code>frule</code> and <code>no_rule</code> e.g with <code>Base.which</code></li><li>if the method of <code>no_frule</code> <code>==</code> the method of <code>frule</code>, then should opt-out</li></ul><p>To just ignore the fact that rules can be opted-out from, and that some rules thus return <code>nothing</code>, then filter the list of methods of <code>frule</code> to remove those that are <code>==</code> to ones that occur in the method table of <code>no_frule</code>.</p><p>Note also when doing this you must still also handle falling back from rule with config, to rule without config.</p><p>On the other-hand if your AD can work with <code>frule</code>s that return <code>nothing</code>, then it is simpler to just use that mechanism for opting out; and you don&#39;t need to worry about this at all.</p><p>For more information see the <a href="opting_out_of_rules.html#opt_out">documentation on opting out of rules</a></p><p>See also <a href="api.html#ChainRulesCore.no_rrule"><code>ChainRulesCore.no_rrule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/19e2a67172e522449beed1ee01af17bc79428e09/src/rules.jl#L192-L228">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="design/many_differentials.html">« Many Differential Types</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 30 August 2021 23:50">Monday 30 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
