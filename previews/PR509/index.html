<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ChainRules</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit">ChainRules</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Introduction</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#frule-and-rrule"><span><code>frule</code> and <code>rrule</code></span></a></li><li><a class="tocitem" href="#Videos"><span>Videos</span></a></li><li><a class="tocitem" href="#Example-of-using-ChainRules-directly"><span>Example of using ChainRules directly</span></a></li></ul></li><li><span class="tocitem">The maths</span><ul><li><a class="tocitem" href="maths/propagators.html">The propagators: pushforward and pullback</a></li><li><a class="tocitem" href="maths/complex.html">Complex numbers</a></li><li><a class="tocitem" href="maths/arrays.html">Deriving array rules</a></li></ul></li><li><span class="tocitem">How to use ChainRules as a rule author</span><ul><li><a class="tocitem" href="rule_author/intro.html">Introduction</a></li><li><a class="tocitem" href="rule_author/differentials.html">Differentials</a></li><li><a class="tocitem" href="rule_author/writing_good_rules.html">Writing good rules</a></li><li><a class="tocitem" href="rule_author/testing.html">Testing your rules</a></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Superpowers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="rule_author/superpowers/projectto.html"><code>ProjectTo</code></a></li><li><a class="tocitem" href="rule_author/superpowers/opt_out.html"><code>@opt_out</code></a></li><li><a class="tocitem" href="rule_author/superpowers/ruleconfig.html"><code>RuleConfig</code></a></li><li><a class="tocitem" href="rule_author/superpowers/gradient_accumulation.html">Gradient accumulation</a></li></ul></li><li><a class="tocitem" href="rule_author/converting_zygoterules.html">Converting ZygoteRules.@adjoint to rrules</a></li><li><a class="tocitem" href="rule_author/tips_for_packages.html">Tips for making your package work with AD</a></li><li><a class="tocitem" href="rule_author/debug_mode.html">Debug mode</a></li></ul></li><li><span class="tocitem">How to support ChainRules rules as an AD package author</span><ul><li><a class="tocitem" href="ad_author/use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="ad_author/call_back_into_ad.html">Suport calling back into ADs</a></li><li><a class="tocitem" href="ad_author/opt_out.html">Support opting out of rules</a></li></ul></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="design/many_differentials.html">Many Differential Types</a></li></ul></li><li><a class="tocitem" href="FAQ.html">FAQ</a></li><li><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ChainRules"><a class="docs-heading-anchor" href="#ChainRules">ChainRules</a><a id="ChainRules-1"></a><a class="docs-heading-anchor-permalink" href="#ChainRules" title="Permalink"></a></h1><p><a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules</a> provides a variety of common utilities that can be used by downstream <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation (AD)</a> tools to define and execute forward-, reverse-, and mixed-mode primitives.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>ChainRules is all about providing a rich set of rules for differentiation. When a person learns introductory calculus, they learn that the derivative (with respect to <code>x</code>) of <code>a*x</code> is <code>a</code>, and the derivative of <code>sin(x)</code> is <code>cos(x)</code>, etc. And they learn how to combine simple rules, via <a href="https://en.wikipedia.org/wiki/Chain_rule">the chain rule</a>, to differentiate complicated functions. ChainRules is a programmatic repository of that knowledge, with the generalizations to higher dimensions.</p><p><a href="https://en.wikipedia.org/wiki/Automatic_differentiation">Autodiff (AD)</a> tools roughly work by reducing a problem down to simple parts that they know the rules for, and then combining those rules. Knowing rules for more complicated functions speeds up the autodiff process as it doesn&#39;t have to break things down as much.</p><p><strong>ChainRules is an AD-independent collection of rules to use in a differentiation system.</strong></p><div class="admonition is-info"><header class="admonition-header">The whole field is a mess for terminology</header><div class="admonition-body"><p>It isn&#39;t just ChainRules, it is everyone. Internally ChainRules tries to be consistent. Help with that is always welcomed.</p></div></div><div class="admonition is-category-terminology"><header class="admonition-header">Primal</header><div class="admonition-body"><p>Often we will talk about something as <em>primal</em>. That means it is related to the original problem, not its derivative. For example in <code>y = foo(x)</code>, <code>foo</code> is the <em>primal</em> function, and computing <code>foo(x)</code> is doing the <em>primal</em> computation. <code>y</code> is the <em>primal</em> return, and <code>x</code> is a <em>primal</em> argument. <code>typeof(y)</code> and <code>typeof(x)</code> are both <em>primal</em> types.</p></div></div><h2 id="frule-and-rrule"><a class="docs-heading-anchor" href="#frule-and-rrule"><code>frule</code> and <code>rrule</code></a><a id="frule-and-rrule-1"></a><a class="docs-heading-anchor-permalink" href="#frule-and-rrule" title="Permalink"></a></h2><div class="admonition is-category-terminology"><header class="admonition-header">`frule` and `rrule`</header><div class="admonition-body"><p><code>frule</code> and <code>rrule</code> are ChainRules specific terms. Their exact functioning is fairly ChainRules specific, though other tools have similar functions. The core notion is sometimes called <em>custom AD primitives</em>, <em>custom adjoints</em>, <em>custom gradients</em>, <em>custom sensitivities</em>.</p></div></div><p>The rules are encoded as <code>frule</code>s and <code>rrule</code>s, for use in forward-mode and reverse-mode differentiation respectively.</p><p>The <code>rrule</code> for some function <code>foo</code>, which takes the positional arguments <code>args</code> and keyword arguments <code>kwargs</code>, is written:</p><pre><code class="language-julia">function rrule(::typeof(foo), args...; kwargs...)
    ...
    return y, pullback
end</code></pre><p>where <code>y</code> (the primal result) must be equal to <code>foo(args...; kwargs...)</code>. <code>pullback</code> is a function to propagate the derivative information backwards at that point. That pullback function is used like: <code>∂self, ∂args... = pullback(Δy)</code></p><p>Almost always the <em>pullback</em> will be declared locally within the <code>rrule</code>, and will be a <em>closure</em> over some of the other arguments, and potentially over the primal result too.</p><p>The <code>frule</code> is written:</p><pre><code class="language-julia">function frule((Δself, Δargs...), ::typeof(foo), args...; kwargs...)
    ...
    return y, ∂Y
end</code></pre><p>where again <code>y = foo(args; kwargs...)</code>, and <code>∂Y</code> is the result of propagating the derivative information forwards at that point. This propagation is call the pushforward. Often we will think of the <code>frule</code> as having the primal computation <code>y = foo(args...; kwargs...)</code>, and the pushforward <code>∂Y = pushforward(Δself, Δargs...)</code>, even though they are not present in seperate forms in the code.</p><div class="admonition is-info"><header class="admonition-header">Why `rrule` returns a pullback but `frule` doesn&#39;t return a pushforward</header><div class="admonition-body"><p>While <code>rrule</code> takes only the arguments to the original function (the primal arguments) and returns a function (the pullback) that operates with the derivative information, the <code>frule</code> does it all at once. This is because the <code>frule</code> fuses the primal computation and the pushforward. This is an optimization that allows <code>frule</code>s to contain single large operations that perform both the primal computation and the pushforward at the same time (for example solving an ODE). This operation is only possible in forward mode (where <code>frule</code> is used) because the derivative information needed by the pushforward available with the <code>frule</code> is invoked – it is about the primal function&#39;s inputs. In contrast, in reverse mode the derivative information needed by the pullback is about the primal function&#39;s output. Thus the reverse mode returns the pullback function which the caller (usually an AD system) keeps hold of until derivative information about the output is available.</p></div></div><h2 id="Videos"><a class="docs-heading-anchor" href="#Videos">Videos</a><a id="Videos-1"></a><a class="docs-heading-anchor-permalink" href="#Videos" title="Permalink"></a></h2><p>For people who learn better by video we have a number of videos of talks we have given about the ChainRules project. Note however, that the videos are frozen in time reflecting the state of the packages at the time they were recorded. This documentation is the continously updated canonical source. However, we have tried to note below each video notes on its correctness.</p><p>The talks that follow are in reverse chronological order (i.e. most recent video is first).</p><h3 id="EuroAD-2021:-ChainRules.jl:-AD-system-agnostic-rules-for-JuliaLang"><a class="docs-heading-anchor" href="#EuroAD-2021:-ChainRules.jl:-AD-system-agnostic-rules-for-JuliaLang">EuroAD 2021: ChainRules.jl: AD system agnostic rules for JuliaLang</a><a id="EuroAD-2021:-ChainRules.jl:-AD-system-agnostic-rules-for-JuliaLang-1"></a><a class="docs-heading-anchor-permalink" href="#EuroAD-2021:-ChainRules.jl:-AD-system-agnostic-rules-for-JuliaLang" title="Permalink"></a></h3><p>Presented by Lyndon White. <a href="https://www.slideshare.net/LyndonWhite2/euroad-2021-chainrulesjl">Slides</a></p><p>This is the talk to watch if you want to understand why the ChainRules project exists, what its challenges are, and how those have been overcome. It is intended less for users of the package, and more for people working in the field of AD more generally. It does also serve as a nice motivation for those first coming across the package as well though.</p><div class="video-container">
<iframe src="https://www.youtube.com/embed/B3bC49OmTdk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div><p>Abstract:</p><blockquote><p>The ChainRules project is a suite of JuliaLang packages that define custom primitives (i.e. rules) for doing AD in JuliaLang. Importantly it is AD system agnostic. It has proved successful in this goal. At present it works with about half a dozen different JuliaLang AD systems. It has been a long journey, but as of August 2021, the core packages have now hit version 1.0.</p><p>This talk will go through why this is useful, the particular objectives the project had, and the challenges that had to be solved. This talk is not intended as an educational guide for users (For that see our 2021 JuliaCon talk: &gt; Everything you need to know about ChainRules 1.0 (https://live.juliacon.org/talk/LWVB39)). Rather this talk is to share the insights we have had, and likely (inadvertently) the mistakes we have made, with the wider autodiff community. We believe these insights can be informative and useful to efforts in other languages and ecosystems.</p></blockquote><h3 id="JuliaCon-2021:-Everything-you-need-to-know-about-ChainRules-1.0"><a class="docs-heading-anchor" href="#JuliaCon-2021:-Everything-you-need-to-know-about-ChainRules-1.0">JuliaCon 2021: Everything you need to know about ChainRules 1.0</a><a id="JuliaCon-2021:-Everything-you-need-to-know-about-ChainRules-1.0-1"></a><a class="docs-heading-anchor-permalink" href="#JuliaCon-2021:-Everything-you-need-to-know-about-ChainRules-1.0" title="Permalink"></a></h3><p>Presented by Miha Zgubič. <a href="https://github.com/mzgubic/ChainRulesTalk/blob/master/ChainRules.pdf">Slides</a></p><p>If you are just wanting to watch a video to learn all about ChainRules and how to use it, watch this one.</p><div class="admonition is-info"><header class="admonition-header">Slide on opting out is incorrect</header><div class="admonition-body"><p>Slide 42 is incorrect (<code>@no_rrule sum_array(A::Diagonal)</code>), in the ChainRulesCore 1.0 release the following syntax is used: <code>@opt_out rrule(::typeof(sum_array), A::Diagonal)</code>. This syntax allows us to include rule config information.</p></div></div><div class="video-container">
<iframe src="https://www.youtube.com/embed/a8ol-1l84gc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div><p>Abstract:</p><blockquote><p>ChainRules is an automatic differentiation (AD)-independent ecosystem for forward-, reverse-, and mixed-mode primitives. It comprises ChainRules.jl, a collection of primitives for Julia Base, ChainRulesCore.jl, the utilities for defining custom primitives, and ChainRulesTestUtils.jl, the utilities to test primitives using finite differences. This talk provides brief updates on the ecosystem since last year and focuses on when and how to write and test custom primitives.</p></blockquote><h3 id="JuliaCon-2020:-ChainRules.jl"><a class="docs-heading-anchor" href="#JuliaCon-2020:-ChainRules.jl">JuliaCon 2020: ChainRules.jl</a><a id="JuliaCon-2020:-ChainRules.jl-1"></a><a class="docs-heading-anchor-permalink" href="#JuliaCon-2020:-ChainRules.jl" title="Permalink"></a></h3><p>Presented by Lyndon White. <a href="https://raw.githack.com/oxinabox/ChainRulesJuliaCon2020/main/out/build/index.html">Slides</a></p><p>This talk is primarily of historical interest. This was the first public presentation of ChainRules. Though the project was a few years old by this stage. A lot of things are still the same; conceptually, but a lot has changed. Most people shouldn&#39;t watch this talk now.</p><div class="admonition is-warning"><header class="admonition-header">Outdated Terminology</header><div class="admonition-body"><p>A lot of terminology has changed since this presentation.</p><ul><li><code>DoesNotExist</code> → <code>NoTangent</code></li><li><code>Zero</code> →  <code>ZeroTangent</code></li><li><code>Composite{P}</code> → <code>Tangent{T}</code></li></ul><p>The talk also says differential in a lot of places where we now would say tangent.</p></div></div><div class="video-container">
<iframe src="https://www.youtube.com/embed/B4NfkkkJ7rs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div><p>Abstract:</p><blockquote><p>The ChainRules project allows package authors to write rules for custom sensitivities (sometimes called custom adjoints) in a way that is not dependent on any particular autodiff (AD) package. It allows authors of AD packages to access a wealth of prewritten custom sensitivities, saving them the effort of writing them all out themselves. ChainRules is the successor to DiffRules.jl and is the native rule system currently used by ForwardDiff2,  Zygote and soon ReverseDiff</p></blockquote><h2 id="Example-of-using-ChainRules-directly"><a class="docs-heading-anchor" href="#Example-of-using-ChainRules-directly">Example of using ChainRules directly</a><a id="Example-of-using-ChainRules-directly-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-using-ChainRules-directly" title="Permalink"></a></h2><p>While ChainRules is largely intended as a backend for autodiff systems, it can be used directly. In fact, this can be very useful if you can constrain the code you need to differentiate to only use things that have rules defined for. This was once how all neural network code worked.</p><p>Using ChainRules directly also helps get a feel for it.</p><pre><code class="language-julia">using ChainRulesCore

function foo(x)
    a = sin(x)
    b = 0.2 + a
    c = asin(b)
    return c
end

# Define rules (alternatively get them for free via `using ChainRules`)
@scalar_rule(sin(x), cos(x))
@scalar_rule(+(x, y), (1.0, 1.0))
@scalar_rule(asin(x), inv(sqrt(1 - x^2)))</code></pre><pre><code class="language-julia">#### Find dfoo/dx via rrules
#### First the forward pass, gathering up the pullbacks
x = 3;
a, a_pullback = rrule(sin, x);
b, b_pullback = rrule(+, 0.2, a);
c, c_pullback = rrule(asin, b)

#### Then the backward pass calculating gradients
c̄ = 1;                    # ∂c/∂c
_, b̄ = c_pullback(c̄);     # ∂c/∂b = ∂c/∂b ⋅ ∂c/∂c
_, _, ā = b_pullback(b̄);  # ∂c/∂a = ∂c/∂b ⋅ ∂b/∂a
_, x̄ = a_pullback(ā);     # ∂c/∂x = ∂c/∂a ⋅ ∂a/∂x
x̄                         # ∂c/∂x = ∂foo/∂x
# output
-1.0531613736418153</code></pre><pre><code class="language-julia">#### Find dfoo/dx via frules
x = 3;
ẋ = 1;              # ∂x/∂x
nofields = ZeroTangent();  # ∂self/∂self

a, ȧ = frule((nofields, ẋ), sin, x);                    # ∂a/∂x = ∂a/∂x ⋅ ∂x/∂x 
b, ḃ = frule((nofields, ZeroTangent(), ȧ), +, 0.2, a);  # ∂b/∂x = ∂b/∂a ⋅ ∂a/∂x
c, ċ = frule((nofields, ḃ), asin, b);                   # ∂c/∂x = ∂c/∂b ⋅ ∂b/∂x
ċ                                                       # ∂c/∂x = ∂foo/∂x
# output
-1.0531613736418153</code></pre><pre><code class="language-julia">#### Find dfoo/dx via FiniteDifferences.jl
using FiniteDifferences
central_fdm(5, 1)(foo, x)
# output
-1.0531613736418257

#### Find dfoo/dx via ForwardDiff.jl
using ForwardDiff
ForwardDiff.derivative(foo, x)
# output
-1.0531613736418153

#### Find dfoo/dx via Zygote.jl
using Zygote
Zygote.gradient(foo, x)
# output
(-1.0531613736418153,)</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="maths/propagators.html">The propagators: pushforward and pullback »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 November 2021 13:01">Friday 5 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
