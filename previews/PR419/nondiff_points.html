<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-differentiable Points · ChainRules</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit">ChainRules</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="FAQ.html">FAQ</a></li><li><a class="tocitem" href="config.html">Rule configurations and calling back into AD</a></li><li><a class="tocitem" href="opting_out_of_rules.html">Opting out of rules</a></li><li><a class="tocitem" href="writing_good_rules.html">Writing Good Rules</a></li><li><a class="tocitem" href="complex.html">Complex Numbers</a></li><li class="is-active"><a class="tocitem" href="nondiff_points.html">Non-differentiable Points</a><ul class="internal"><li><a class="tocitem" href="#What-is-the-sub/super-differential?"><span>What is the sub/super-differential?</span></a></li><li><a class="tocitem" href="#What-is-useful-?"><span>What is useful ?</span></a></li><li><a class="tocitem" href="#Why-is-the-sub/super-differential-convention-permissible?"><span>Why is the sub/super-differential convention permissible?</span></a></li><li><a class="tocitem" href="#How-does-this-generalize-to-n-D"><span>How does this generalize to n-D</span></a></li></ul></li><li><a class="tocitem" href="arrays.html">Deriving Array Rules</a></li><li><a class="tocitem" href="debug_mode.html">Debug Mode</a></li><li><a class="tocitem" href="gradient_accumulation.html">Gradient Accumulation</a></li><li><a class="tocitem" href="use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="converting_zygoterules.html">Converting ZygoteRules</a></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="design/many_differentials.html">Many Differential Types</a></li></ul></li><li><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="nondiff_points.html">Non-differentiable Points</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="nondiff_points.html">Non-differentiable Points</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/nondiff_points.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="What-to-return-for-non-differentiable-points"><a class="docs-heading-anchor" href="#What-to-return-for-non-differentiable-points">What to return for non-differentiable points</a><a id="What-to-return-for-non-differentiable-points-1"></a><a class="docs-heading-anchor-permalink" href="#What-to-return-for-non-differentiable-points" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">What is the short version?</header><div class="admonition-body"><p>If the function is not differentiable due to e.g. a branch, like <code>abs</code>, your rule can reasonably claim the derivative at that point is the value from either branch, <em>or</em> any value in-between (e.g. for <code>abs</code> claiming 0 is a good idea). If it is not differentiable due to the primal not being defined on one side, you can set it to what ever you like. Your rule should claim a derivative that is <em>useful</em>.</p></div></div><p>In calculus one learns that if the derivative as computed by approaching from the left, and the derivative one computes as approaching from the right are not equal then the derivative is not defined, and we say the function is not differentiable at that point. This is distinct from the notion captured by <a href="api.html#ChainRulesCore.NoTangent"><code>NoTangent</code></a>, which is that the tangent space itself is not defined: because in some sense the primal value can not be perturbed e.g. is is a discrete type.</p><p>However, contrary to what calculus says most autodiff systems will return an answer for such functions. For example for: <code>abs_left(x) = (x &lt;= 0) ? -x : x</code>, AD will say the derivative at <code>x=0</code> is <code>-1</code>. Alternatively for:  <code>abs_right(x) = (x &lt; 0) ? -x : x</code>, AD will say the derivative at <code>x=0</code> is <code>1</code>. Those two examples are weird since they are equal at all points, but AD claims different derivatives at <code>x=0</code>. The way to fix autodiff systems being weird is to write custom rules. So what rule should we write for this case?</p><p>The obvious answer, would be to write a rule that throws an error if input at a point where calculus says the derivative is not defined. Another option is to return some error signally value like <code>NaN</code>. Which you <em>can</em> do. However, this is not useful. Instead we introduce what we call the <strong>sub/super-differential convention</strong>:</p><blockquote><p>It is always permissible to return any element of the sub/super-differential. You should return the most useful.</p></blockquote><p>Or equivalently but considering the trivial singleton sub/super-differential seperately:</p><blockquote><p>At any point where the derivative is not defined, it is permissible to return any element of the sub/super-differential. You should return the most useful.</p></blockquote><p>We will justify this further below, but first let us discuss what it means.</p><h2 id="What-is-the-sub/super-differential?"><a class="docs-heading-anchor" href="#What-is-the-sub/super-differential?">What is the sub/super-differential?</a><a id="What-is-the-sub/super-differential?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-the-sub/super-differential?" title="Permalink"></a></h2><p>The subderivative is defined only for locally convex functions, where-as the super-deriviative is fined only for locally concave functions. For our purpose we, basically never care which we are working with  and so write sub/super-derivative.</p><p>For a function <span>$f$</span> at some point <span>$x_0$</span> a sub/super-derivative is a real number <span>$c$</span> such that there exists a open ball <span>$\mathcal{B} \subset \mathrm{dom}(f)$</span> containing <span>$x_0$</span>, and for all points <span>$z \in \mathcal{B}$</span> the following holds:</p><p class="math-container">\[\mathrm{sub -derivative:}\qquad f(z) - f(x_0) \ge c\,(z-x_0)\]</p><p class="math-container">\[\mathrm{super-derivative:}\qquad f(z) - f(x_0) \le c\,(z-x_0)\]</p><p>We call the the set of all values <span>$c$</span> the sub/super-differential at <span>$x_0$</span>.</p><p>More informally: consider a plot of the function. The sub/super-differential at a point is the set of slopes of all lines you could draw touching that point, but with the lines either entirely above, or entirely below the curve.</p><p>It is best illustrated with a figure:</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4e/Subderivative_illustration.png" alt="plot showing subderiviatives"/></p><p>In this figure a plot of a function is shown in blue. Two subtangent lines are plotted in red. Their slopes are sub/super-derivatives at <span>$x_0$</span>, and they are two elements of the subdifferential. If you flip it upside down, it would apply for the super-differential, with the lines being above the curve.</p><h3 id="Some-key-things-to-note."><a class="docs-heading-anchor" href="#Some-key-things-to-note.">Some key things to note.</a><a id="Some-key-things-to-note.-1"></a><a class="docs-heading-anchor-permalink" href="#Some-key-things-to-note." title="Permalink"></a></h3><p>For a function where the derivative is defined on both sides of the point:</p><ul><li>the derivative on each side is a sub/super-derivative at the point</li><li>as is the mean of the derivative of each side</li><li>in-fact the mean of any subset (including the whole sub/super-differential) of sub/super-derivatives is also a sub/super-derivative.</li><li>if the derivative one one side is negative and the other positive then zero is a sub/super-derivative.</li></ul><p>For a function that is only defined on one side of the point, the sub/super-differential is the full set of real numbers. This by the subgradient convention leaves you free to chose <em>any</em> useful value.</p><div class="admonition is-info"><header class="admonition-header">Does AD always return a sub/super-derivative? No</header><div class="admonition-body"><p>On consideration of this, one might be tempted to think that AD always returns a sub/super-derivative. And that in normal cases it return the only sub/super-derivative i.e. the actual derivative; and in other case it picks one of the branches. Thus all weirdness of AD disagreeing with calculus could be explained away in this way. <strong>This is not the case.</strong> As it is not necessarily true that all branches derivatives are correct sub/super-differentials for the function. Consider the function from <a href="https://dl.acm.org/doi/10.1145/3371106">Abadi and Plotkin, 2019</a>: <code>f(x::Float64) = x == 0.0 ? 0.0 : x</code>. The correct derivative of this function is <code>1</code> at all points, but most ADs will say that at <code>x=0</code> the derivative is zero. The fix for this, is to define a rule which <em>does</em> in fact return a sub/super-derivative. So one could say a correctly functioning AD with all needed rules does always return a sub/super-differential.</p></div></div><h2 id="What-is-useful-?"><a class="docs-heading-anchor" href="#What-is-useful-?">What is useful ?</a><a id="What-is-useful-?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-useful-?" title="Permalink"></a></h2><p>The sub/super-differential convention had two parts: &quot;It is always permissable to return any element of the sub/super-differential. <strong>You should return the most useful.</strong>&quot;. What is the most useful? This is a value judgement you as a rule author will have to make.</p><h3 id="It-is-often-zero"><a class="docs-heading-anchor" href="#It-is-often-zero">It is often zero</a><a id="It-is-often-zero-1"></a><a class="docs-heading-anchor-permalink" href="#It-is-often-zero" title="Permalink"></a></h3><p>If zero is a sub/super-derivative, then it is often the most useful one. Especially if the point is a local minima/maxima For a function like <code>abs</code> or <code>x -&gt; x&lt;0 ? x : -2x</code> setting the non-differentiable point to either side would result in it leaving that maxima.</p><p>Further, a nice (albeit generally intractable) algorithm for finding the global optima is to take the set of all stationary points (i.e. points where the derivative is zero), combine that with the boundary points and evaluate the primal function at all of them. The extrema of this set are the global optima. This algorithm is only guaranteed correct for functions that are differentiable everywhere <em>or</em> that apply the sub/super-derivative convention and make all non-differentiable local optima claim to have a zero derivative. It is also correct if you make other non-differentiable points have zero derivative, just slower.</p><h3 id="It-is-sometimes-the-non-zero,-especially-if-it-boarders-a-flat-section"><a class="docs-heading-anchor" href="#It-is-sometimes-the-non-zero,-especially-if-it-boarders-a-flat-section">It is sometimes the non-zero, especially if it boarders a flat section</a><a id="It-is-sometimes-the-non-zero,-especially-if-it-boarders-a-flat-section-1"></a><a class="docs-heading-anchor-permalink" href="#It-is-sometimes-the-non-zero,-especially-if-it-boarders-a-flat-section" title="Permalink"></a></h3><p>If a function has derivative zero in some large section of it&#39;s domain, like <code>relu</code> or <code>x-&gt;clamp(x, -1, 1)</code>, a case can be made for choosing the non-zero derivative branch. Depending exactly on the larger function being optimized, it is often the case that a zero gradient for this function means a total zero gradient (e.g. if the greater function is a chain of composed calls). So once things move into the flat-region they stay there. If we chose the other branch we move them into (just barely) the nonflat region. If moving into the non-flat region was good they will move further there later. If it is not good then they well be rapidly cast deeper into the flat region and we will not be at this boundary case.</p><h3 id="It-is-sometimes-the-mean"><a class="docs-heading-anchor" href="#It-is-sometimes-the-mean">It is sometimes the mean</a><a id="It-is-sometimes-the-mean-1"></a><a class="docs-heading-anchor-permalink" href="#It-is-sometimes-the-mean" title="Permalink"></a></h3><p>Either the mean of the branches, or the overall mean of the sub/super-differential (which may be equal).</p><p>A nice advantage of it is that it will agree with the result you will get from central finite differencing. Which is what <a href="https://github.com/JuliaDiff/ChainRulesTestUtils.jl">ChainRulesTestUtils.jl</a> defaults to.</p><h3 id="All-else-being-equal-it-is-just-one-of-the-branches"><a class="docs-heading-anchor" href="#All-else-being-equal-it-is-just-one-of-the-branches">All else being equal it is just one of the branches</a><a id="All-else-being-equal-it-is-just-one-of-the-branches-1"></a><a class="docs-heading-anchor-permalink" href="#All-else-being-equal-it-is-just-one-of-the-branches" title="Permalink"></a></h3><p>Pick one. It will be fast. It will agree with either the forwards or reverse finite differencing results.</p><h3 id="It-is-almost-never-Inf,-NaN-or-an-error"><a class="docs-heading-anchor" href="#It-is-almost-never-Inf,-NaN-or-an-error">It is almost never <code>Inf</code>, <code>NaN</code> or an error</a><a id="It-is-almost-never-Inf,-NaN-or-an-error-1"></a><a class="docs-heading-anchor-permalink" href="#It-is-almost-never-Inf,-NaN-or-an-error" title="Permalink"></a></h3><p>Practically speaking, people are generally using AD to perform some gradient descent like optimization procedure. <code>NaN</code> and <code>Inf</code> do not generally take us to nice places. Erroring can be worse, especially if it is a local minima – the optimization fully converges to that minima and then throws an error rather than reporting the result. If the primal function takes a non-finite value or errors on one side, then we are in the case that we are at a boundry of the domain. Which means we are free to chose <em>any</em> value. In particular we often want to chose value of the derivative from <strong>the other side where the primal is defined.</strong></p><h2 id="Why-is-the-sub/super-differential-convention-permissible?"><a class="docs-heading-anchor" href="#Why-is-the-sub/super-differential-convention-permissible?">Why is the sub/super-differential convention permissible?</a><a id="Why-is-the-sub/super-differential-convention-permissible?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-is-the-sub/super-differential-convention-permissible?" title="Permalink"></a></h2><p>Math isn&#39;t real, and AD doesn&#39;t do calculus. We are trying to accomplish some goal, and this approach works well.</p><p>One way to think about this  convention is to take an infinitely sharp discontinuity in a function and replace that discontinuty with a very (infinitesimally) small, smooth corner. Due to the intermediate value theorem, we can then say that over this tiny interval, any derivative between the two extremes is realized and we are free to pick any one of them that we find useful as the &#39;canonical&#39; value.</p><p>More specifically, consider our initial examples: <code>abs_left(x) = (x &lt;= 0) ? -x : x</code>, and <code>abs_right(x) = (x &lt; 0) ? -x : x</code>. These are a a primal level indistinguishable to the user. It is impossible to tell which <code>Base.abs</code> uses without looking at the source. Thus the rule author must be free to chose between assuming it is either. Which is equivalent to saying they are free to chose to return the derivative or either branch. We can then take the continuous relaxation of that choice: to chose any value between them. Which for that case is choosing any sub-differential. We then generalize from that chose into the sub/super-differential convention.</p><h2 id="How-does-this-generalize-to-n-D"><a class="docs-heading-anchor" href="#How-does-this-generalize-to-n-D">How does this generalize to n-D</a><a id="How-does-this-generalize-to-n-D-1"></a><a class="docs-heading-anchor-permalink" href="#How-does-this-generalize-to-n-D" title="Permalink"></a></h2><p>Carefully, but consistently.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="complex.html">« Complex Numbers</a><a class="docs-footer-nextpage" href="arrays.html">Deriving Array Rules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 28 July 2021 10:11">Wednesday 28 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
