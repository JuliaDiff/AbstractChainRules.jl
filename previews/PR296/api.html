<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ChainRules</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/chainrules.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit">ChainRules</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="FAQ.html">FAQ</a></li><li><a class="tocitem" href="writing_good_rules.html">Writing Good Rules</a></li><li><a class="tocitem" href="complex.html">Complex Numbers</a></li><li><a class="tocitem" href="arrays.html">Deriving Array Rules</a></li><li><a class="tocitem" href="debug_mode.html">Debug Mode</a></li><li><a class="tocitem" href="gradient_accumulation.html">Gradient Accumulation</a></li><li><span class="tocitem">Usage in AD</span><ul><li><a class="tocitem" href="autodiff/overview.html">Overview</a></li><li><a class="tocitem" href="autodiff/operator_overloading.html">Operator Overloading</a></li></ul></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="design/many_differentials.html">Many Differential Types</a></li></ul></li><li class="is-active"><a class="tocitem" href="api.html">API</a><ul class="internal"><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Rule-Definition-Tools"><span>Rule Definition Tools</span></a></li><li><a class="tocitem" href="#Differentials"><span>Differentials</span></a></li><li><a class="tocitem" href="#Accumulation"><span>Accumulation</span></a></li><li><a class="tocitem" href="#Ruleset-Loading"><span>Ruleset Loading</span></a></li><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.frule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">frule((Δf, Δx...), f, x...)</code></pre><p>Expressing the output of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, ΔΩ)</code></pre><p>The second return value is the differential w.r.t. the output.</p><p>If no method matching <code>frule((Δf, Δx...), f, x...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; dself = NO_FIELDS;

julia&gt; x = rand()
0.8236475079774124

julia&gt; sinx, Δsinx = frule((dself, 1), sin, x)
(0.7336293678134624, 0.6795498147167869)

julia&gt; sinx == sin(x)
true

julia&gt; Δsinx == cos(x)
true</code></pre><p>Unary input, binary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; sincosx, Δsincosx = frule((dself, 1), sincos, x);

julia&gt; sincosx == sincos(x)
true

julia&gt; Δsincosx[1] == cos(x)
true

julia&gt; Δsincosx[2] == -sin(x)
true</code></pre><p>Note that techically speaking julia does not have multiple output functions, just functions that return a single output that is iterable, like a <code>Tuple</code>. So this is actually a <a href="api.html#ChainRulesCore.Composite"><code>Composite</code></a>:</p><pre><code class="language-julia-repl">julia&gt; Δsincosx
Composite{Tuple{Float64,Float64}}(0.6795498147167869, -0.7336293678134624)</code></pre><p>.</p><p>See also: <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/rules.jl#L1-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.rrule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rrule(f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (Ω̄₁, Ω̄₂, ...) -&gt; (s̄elf, x̄₁, x̄₂, ...))</code></pre><p>Where the second return value is the the propagation rule or pullback. It takes in differentials corresponding to the outputs (<code>x̄₁, x̄₂, ...</code>), and <code>s̄elf</code>, the internal values of the function itself (for closures)</p><p>If no method matching <code>rrule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x = rand();

julia&gt; sinx, sin_pullback = rrule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; sin_pullback(1) == (NO_FIELDS, cos(x))
true</code></pre><p>binary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x, y = rand(2);

julia&gt; hypotxy, hypot_pullback = rrule(hypot, x, y);

julia&gt; hypotxy == hypot(x, y)
true

julia&gt; hypot_pullback(1) == (NO_FIELDS, (x / hypot(x, y)), (y / hypot(x, y)))
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/rules.jl#L60-L105">source</a></section></article><h2 id="Rule-Definition-Tools"><a class="docs-heading-anchor" href="#Rule-Definition-Tools">Rule Definition Tools</a><a id="Rule-Definition-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Definition-Tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.@non_differentiable-Tuple{Any}" href="#ChainRulesCore.@non_differentiable-Tuple{Any}"><code>ChainRulesCore.@non_differentiable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@non_differentiable(signature_expression)</code></pre><p>A helper to make it easier to declare that a method is not not differentiable. This is a short-hand for defining an <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a> and <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a> that return <a href="api.html#ChainRulesCore.DoesNotExist"><code>DoesNotExist()</code></a> for all partials (except for the function <code>s̄elf</code>-partial itself which is <code>NO_FIELDS</code>)</p><p>Keyword arguments should not be included.</p><pre><code class="language-julia-repl">julia&gt; @non_differentiable Base.:(==)(a, b)

julia&gt; _, pullback = rrule(==, 2.0, 3.0);

julia&gt; pullback(1.0)
(Zero(), DoesNotExist(), DoesNotExist())</code></pre><p>You can place type-constraints in the signature:</p><pre><code class="language-julia-repl">julia&gt; @non_differentiable Base.length(xs::Union{Number, Array})

julia&gt; frule((Zero(), 1), length, [2.0, 3.0])
(2, DoesNotExist())</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This helper macro covers only the simple common cases. It does not support <code>where</code>-clauses. For these you can declare the <code>rrule</code> and <code>frule</code> directly</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/rule_definition_tools.jl#L264-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}" href="#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>ChainRulesCore.@scalar_rule</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@scalar_rule(f(x₁, x₂, ...),
             @setup(statement₁, statement₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>A convenience macro that generates simple scalar forward or reverse rules using the provided partial derivatives. Specifically, generates the corresponding methods for <code>frule</code> and <code>rrule</code>:</p><pre><code class="language-none">function ChainRulesCore.frule((NO_FIELDS, Δx₁, Δx₂, ...), ::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (
            (∂f₁_∂x₁ * Δx₁ + ∂f₁_∂x₂ * Δx₂ + ...),
            (∂f₂_∂x₁ * Δx₁ + ∂f₂_∂x₂ * Δx₂ + ...),
            ...
        )
end

function ChainRulesCore.rrule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, ((ΔΩ₁, ΔΩ₂, ...)) -&gt; (
            NO_FIELDS,
            ∂f₁_∂x₁ * ΔΩ₁ + ∂f₂_∂x₁ * ΔΩ₂ + ...),
            ∂f₁_∂x₂ * ΔΩ₁ + ∂f₂_∂x₂ * ΔΩ₂ + ...),
            ...
        )
end</code></pre><p>If no type constraints in <code>f(x₁, x₂, ...)</code> within the call to <code>@scalar_rule</code> are provided, each parameter in the resulting <code>frule</code>/<code>rrule</code> definition is given a type constraint of <code>Number</code>. Constraints may also be explicitly be provided to override the <code>Number</code> constraint, e.g. <code>f(x₁::Complex, x₂)</code>, which will constrain <code>x₁</code> to <code>Complex</code> and <code>x₂</code> to <code>Number</code>.</p><p>At present this does not support defining for closures/functors. Thus in reverse-mode, the first returned partial, representing the derivative with respect to the function itself, is always <code>NO_FIELDS</code>. And in forward-mode, the first input to the returned propagator is always ignored.</p><p>The result of <code>f(x₁, x₂, ...)</code> is automatically bound to <code>Ω</code>. This allows the primal result to be conveniently referenced (as <code>Ω</code>) within the derivative/setup expressions.</p><p>This macro assumes complex functions are holomorphic. In general, for non-holomorphic functions, the <code>frule</code> and <code>rrule</code> must be defined manually.</p><p>The <code>@setup</code> argument can be elided if no setup code is need. In other words:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>is equivalent to:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             @setup(nothing),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>For examples, see ChainRules&#39; <code>rulesets</code> directory.</p><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/rule_definition_tools.jl#L2-L72">source</a></section></article><h2 id="Differentials"><a class="docs-heading-anchor" href="#Differentials">Differentials</a><a id="Differentials-1"></a><a class="docs-heading-anchor-permalink" href="#Differentials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.AbstractZero" href="#ChainRulesCore.AbstractZero"><code>ChainRulesCore.AbstractZero</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractZero &lt;: AbstractDifferential</code></pre><p>Supertype for zero-like differentials—i.e., differentials that act like zero when added or multiplied to other values. If an AD system encounters a propagator that takes as input only subtypes of <code>AbstractZero</code>, then it can stop performing AD operations. All propagators are linear functions, and thus the final result will be zero.</p><p>All <code>AbstractZero</code> subtypes are singleton types. There are two of them: <a href="api.html#ChainRulesCore.Zero"><code>Zero()</code></a> and <a href="api.html#ChainRulesCore.DoesNotExist"><code>DoesNotExist()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/abstract_zero.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.DoesNotExist" href="#ChainRulesCore.DoesNotExist"><code>ChainRulesCore.DoesNotExist</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DoesNotExist() &lt;: AbstractZero</code></pre><p>This differential indicates that the derivative does not exist. It is the differential for primal types that are not differentiable, such as integers or booleans (when they are not being used to represent floating-point values). The only valid way to perturb such values is to not change them at all. As a consequence, <code>DoesNotExist</code> is functionally identical to <code>Zero()</code>, but it provides additional semantic information.</p><p>Adding this differential to a primal is generally wrong: gradient-based methods cannot be used to optimize over discrete variables. An optimization package making use of this might want to check for such a case.</p><p>!!! note:     This does not indicate that the derivative is not implemented,     but rather that mathematically it is not defined.</p><p>This mostly shows up as the derivative with respect to dimension, index, or size arguments.</p><pre><code class="language-none">    function rrule(fill, x, len::Int)
        y = fill(x, len)
        fill_pullback(ȳ) = (NO_FIELDS, @thunk(sum(Ȳ)), DoesNotExist())
        return y, fill_pullback
    end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/abstract_zero.jl#L45-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.Zero" href="#ChainRulesCore.Zero"><code>ChainRulesCore.Zero</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Zero() &lt;: AbstractZero</code></pre><p>The additive identity for differentials. This is basically the same as <code>0</code>. A derivative of <code>Zero()</code> does not propagate through the primal function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/abstract_zero.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.One" href="#ChainRulesCore.One"><code>ChainRulesCore.One</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> One()</code></pre><p>The Differential which is the multiplicative identity. Basically, this represents <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/one.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.NO_FIELDS" href="#ChainRulesCore.NO_FIELDS"><code>ChainRulesCore.NO_FIELDS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">NO_FIELDS</code></pre><p>Constant for the reverse-mode derivative with respect to a structure that has no fields. The most notable use for this is for the reverse-mode derivative with respect to the function itself, when that function is not a closure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/composite.jl#L299-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.Composite" href="#ChainRulesCore.Composite"><code>ChainRulesCore.Composite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Composite{P, T} &lt;: AbstractDifferential</code></pre><p>This type represents the differential for a <code>struct</code>/<code>NamedTuple</code>, or <code>Tuple</code>. <code>P</code> is the the corresponding primal type that this is a differential for.</p><p><code>Composite{P}</code> should have fields (technically properties), that match to a subset of the fields of the primal type; and each should be a differential type matching to the primal type of that field. Fields of the P that are not present in the Composite are treated as <code>Zero</code>.</p><p><code>T</code> is an implementation detail representing the backing data structure. For Tuple it will be a Tuple, and for everything else it will be a <code>NamedTuple</code>. It should not be passed in by user.</p><p>For <code>Composite</code>s of <code>Tuple</code>s, <code>iterate</code> and <code>getindex</code> are overloaded to behave similarly to for a tuple. For <code>Composite</code>s of <code>struct</code>s, <code>getproperty</code> is overloaded to allow for accessing values via <code>comp.fieldname</code>. Any fields not explictly present in the <code>Composite</code> are treated as being set to <code>Zero()</code>. To make a <code>Composite</code> have all the fields of the primal the <a href="api.html#ChainRulesCore.canonicalize-Union{Tuple{Composite{P,var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(NamedTuple{L,T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where L where P"><code>canonicalize</code></a> function is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/composite.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.canonicalize-Union{Tuple{Composite{P,var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(NamedTuple{L,T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where L where P" href="#ChainRulesCore.canonicalize-Union{Tuple{Composite{P,var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(NamedTuple{L,T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where L where P"><code>ChainRulesCore.canonicalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">canonicalize(comp::Composite{P}) -&gt; Composite{P}</code></pre><p>Return the canonical <code>Composite</code> for the primal type <code>P</code>. The property names of the returned <code>Composite</code> match the field names of the primal, and all fields of <code>P</code> not present in the input <code>comp</code> are explictly set to <code>Zero()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/composite.jl#L158-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.InplaceableThunk" href="#ChainRulesCore.InplaceableThunk"><code>ChainRulesCore.InplaceableThunk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InplaceableThunk(val::Thunk, add!::Function)</code></pre><p>A wrapper for a <code>Thunk</code>, that allows it to define an inplace <code>add!</code> function.</p><p><code>add!</code> should be defined such that: <code>ithunk.add!(Δ) = Δ .+= ithunk.val</code> but it should do this more efficently than simply doing this directly. (Otherwise one can just use a normal <code>Thunk</code>).</p><p>Most operations on an <code>InplaceableThunk</code> treat it just like a normal <code>Thunk</code>; and destroy its inplacability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/thunks.jl#L103-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.Thunk" href="#ChainRulesCore.Thunk"><code>ChainRulesCore.Thunk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Thunk(()-&gt;v)</code></pre><p>A thunk is a deferred computation. It wraps a zero argument closure that when invoked returns a differential. <code>@thunk(v)</code> is a macro that expands into <code>Thunk(()-&gt;v)</code>.</p><p>Calling a thunk, calls the wrapped closure. If you are unsure if you have a <code>Thunk</code>, call <a href="api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a> which is a no-op when the argument is not a <code>Thunk</code>. If you need to unthunk recursively, call <a href="api.html#ChainRulesCore.extern-Tuple{Any}"><code>extern</code></a>, which also externs the differial that the closure returns.</p><pre><code class="language-julia-repl">julia&gt; t = @thunk(@thunk(3))
Thunk(var&quot;#4#6&quot;())

julia&gt; extern(t)
3

julia&gt; t()
Thunk(var&quot;#5#7&quot;())

julia&gt; t()()
3</code></pre><p><strong>When to <code>@thunk</code>?</strong></p><p>When writing <code>rrule</code>s (and to a lesser exent <code>frule</code>s), it is important to <code>@thunk</code> appropriately. Propagation rules that return multiple derivatives may not have all deriviatives used.  By <code>@thunk</code>ing the work required for each derivative, they then compute only what is needed.</p><p><strong>How do thunks prevent work?</strong></p><p>If we have <code>res = pullback(...) = @thunk(f(x)), @thunk(g(x))</code> then if we did <code>dx + res[1]</code> then only <code>f(x)</code> would be evaluated, not <code>g(x)</code>. Also if we did <code>Zero() * res[1]</code> then the result would be <code>Zero()</code> and <code>f(x)</code> would not be evaluated.</p><p><strong>So why not thunk everything?</strong></p><p><code>@thunk</code> creates a closure over the expression, which (effectively) creates a <code>struct</code> with a field for each variable used in the expression, and call overloaded.</p><p>Do not use <code>@thunk</code> if this would be equal or more work than actually evaluating the expression itself. This is commonly the case for scalar operators.</p><p>For more details see the manual section <a href="http://www.juliadiff.org/ChainRulesCore.jl/dev/writing_good_rules.html#Use-Thunks-appropriately-1">on using thunks effectively</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/thunks.jl#L48-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.unthunk-Tuple{Any}" href="#ChainRulesCore.unthunk-Tuple{Any}"><code>ChainRulesCore.unthunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unthunk(x)</code></pre><p>On <code>AbstractThunk</code>s this removes 1 layer of thunking. On any other type, it is the identity operation.</p><p>In contrast to <a href="api.html#ChainRulesCore.extern-Tuple{Any}"><code>extern</code></a> this is nonrecursive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/thunks.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.@thunk-Tuple{Any}" href="#ChainRulesCore.@thunk-Tuple{Any}"><code>ChainRulesCore.@thunk</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@thunk expr</code></pre><p>Define a <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> wrapping the <code>expr</code>, to lazily defer its evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/thunks.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.extern-Tuple{Any}" href="#ChainRulesCore.extern-Tuple{Any}"><code>ChainRulesCore.extern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extern(x)</code></pre><p>Makes a best effort attempt to convert a differential into a primal value. This is not always a well-defined operation. For two reasons:</p><ul><li>It may not be possible to determine the primal type for a given differential.</li></ul><p>For example, <code>Zero</code> is a valid differential for any primal.</p><ul><li>The primal type might not be a vector space, thus might not be a valid differential type.</li></ul><p>For example, if the primal type is <code>DateTime</code>, it&#39;s not a valid differential type as two  <code>DateTime</code> can not be added (fun fact: <code>Milisecond</code> is a differential for <code>DateTime</code>).</p><p>Where it is defined the operation of <code>extern</code> for a primal type <code>P</code> should be <code>extern(x) = zero(P) + x</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Because of its limitations, <code>extern</code> should only really be used for testing. It can be useful, if you know what you are getting out, as it recursively removes thunks, and otherwise makes outputs more consistent with finite differencing.</p><p>The more useful action in general is to call <code>+</code>, or in the case of a <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> to call <a href="api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>extern</code> may return an alias (not necessarily a copy) to data wrapped by <code>x</code>, such that mutating <code>extern(x)</code> might mutate <code>x</code> itself.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/abstract_differential.jl#L40-L66">source</a></section></article><h2 id="Accumulation"><a class="docs-heading-anchor" href="#Accumulation">Accumulation</a><a id="Accumulation-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.add!!" href="#ChainRulesCore.add!!"><code>ChainRulesCore.add!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add!!(x, y)</code></pre><p>Returns <code>x+y</code>, potentially mutating <code>x</code> in-place to hold this value. This avoids allocations when <code>x</code> can be mutated in this way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/accumulation.jl#L1-L6">source</a></section><section><div><pre><code class="language-none">add!!(x, t::ImplacableThunk)</code></pre><p>The specialization of <code>add!!</code> for <a href="api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a> promises to only call <code>t.add!</code> on <code>x</code> if <code>x</code> is suitably mutable; otherwise it will be out of place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/accumulation.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.is_inplaceable_destination" href="#ChainRulesCore.is_inplaceable_destination"><code>ChainRulesCore.is_inplaceable_destination</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_inplaceable_destination(x) -&gt; Bool</code></pre><p>Returns true if <code>x</code> is suitable for for storing inplace accumulation of gradients. For arrays this boils down <code>x .= y</code> if will work to mutate <code>x</code>, if <code>y</code> is an appropriate differential. Wrapper array types do not need to overload this if they overload <code>Base.parent</code>, and are <code>is_inplaceable_destination</code> if and only if their parent array is. Other types should overload this, as it defaults to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/accumulation.jl#L36-L45">source</a></section></article><h2 id="Ruleset-Loading"><a class="docs-heading-anchor" href="#Ruleset-Loading">Ruleset Loading</a><a id="Ruleset-Loading-1"></a><a class="docs-heading-anchor-permalink" href="#Ruleset-Loading" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.on_new_rule-Tuple{Any,Any}" href="#ChainRulesCore.on_new_rule-Tuple{Any,Any}"><code>ChainRulesCore.on_new_rule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">on_new_rule(hook, frule | rrule)</code></pre><p>Register a <code>hook</code> function to run when new rules are defined. The hook receives a signature type-type as input, and generally will use <code>eval</code> to define an overload of an AD system&#39;s overloaded type For example, using the signature type <code>Tuple{typeof(+), Real, Real}</code> to make <code>+(::DualNumber, ::DualNumber)</code> call the <code>frule</code> for <code>+</code>. A signature type tuple always has the form: <code>Tuple{typeof(operation), typeof{pos_arg1}, typeof{pos_arg2}...}</code>, where <code>pos_arg1</code> is the first positional argument.</p><p>The hooks are automatically run on new rules whenever a package is loaded. They can be manually triggered by <a href="api.html#ChainRulesCore.refresh_rules-Tuple{}"><code>refresh_rules</code></a>. When a hook is first registered with <code>on_new_rule</code> it is run on all existing rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/ruleset_loading.jl#L13-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.refresh_rules-Tuple{}" href="#ChainRulesCore.refresh_rules-Tuple{}"><code>ChainRulesCore.refresh_rules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">refresh_rules()
refresh_rules(frule | rrule)</code></pre><p>This triggers all <a href="api.html#ChainRulesCore.on_new_rule-Tuple{Any,Any}"><code>on_new_rule</code></a> hooks to run on any newly defined rules. It is <em>automatically</em> run when ever a package is loaded. It can also be manually called to run it directly, for example if a rule was defined in the REPL or within the same file as the AD function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/ruleset_loading.jl#L70-L78">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.AbstractDifferential" href="#ChainRulesCore.AbstractDifferential"><code>ChainRulesCore.AbstractDifferential</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The subtypes of <code>AbstractDifferential</code> define a custom &quot;algebra&quot; for chain rule evaluation that attempts to factor various features like complex derivative support, broadcast fusion, zero-elision, etc. into nicely separated parts.</p><p>In general a differential type is the type of a derivative of a value. The type of the value is for contrast called the primal type. Differential types correspond to primal types, although the relation is not one-to-one. Subtypes of  <code>AbstractDifferential</code> are not the only differential types. In fact for the most common primal types, such as <code>Real</code> or <code>AbstractArray{Real}</code> the the differential type is the same as the primal type.</p><p>In a circular definition: the most important property of a differential is that it should be able to be added (by defining <code>+</code>) to another differential of the same primal type. That allows for gradients to be accumulated.</p><p>It generally also should be able to be added to a primal to give back another primal, as this facilitates gradient descent.</p><p>All subtypes of <code>AbstractDifferential</code> implement the following operations:</p><ul><li><code>+(a, b)</code>: linearly combine differential <code>a</code> and differential <code>b</code></li><li><code>*(a, b)</code>: multiply the differential <code>b</code> by the scaling factor <code>a</code></li><li><code>Base.zero(x) = Zero()</code>: a zero.</li></ul><p>Further, they often implement other linear operators, such as <code>conj</code>, <code>adjoint</code>, <code>dot</code>. Pullbacks/pushforwards are linear operators, and their inputs are often <code>AbstractDifferential</code> subtypes. Pullbacks/pushforwards in-turn call other linear operators on those inputs. Thus it is desirable to have all common linear operators work on <code>AbstractDifferential</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/differentials/abstract_differential.jl#L5-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.debug_mode" href="#ChainRulesCore.debug_mode"><code>ChainRulesCore.debug_mode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">debug_mode() -&gt; Bool</code></pre><p>Determines if ChainRulesCore is in <code>debug_mode</code>. Defaults to <code>false</code>, but if the user redefines it to return <code>true</code> then extra information will be shown when errors occur.</p><p>Enable via:</p><pre><code class="language-none">ChainRulesCore.debug_mode() = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/debug_mode.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.clear_new_rule_hooks!" href="#ChainRulesCore.clear_new_rule_hooks!"><code>ChainRulesCore.clear_new_rule_hooks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">clear_new_rule_hooks!(frule|rrule)</code></pre><p>Clears all hooks that were registered with corresponding <a href="api.html#ChainRulesCore.on_new_rule-Tuple{Any,Any}"><code>on_new_rule</code></a>. This is useful for while working interactively to define your rule generating hooks. If you previously wrong an incorrect hook, you can use this to get rid of the old one.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This absolutely should not be used in a package, as it will break any other AD system using the rule hooks that might happen to be loaded.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/f19c66a8b5e8ed7ea47fefbd9996e5f52f5aad56/src/ruleset_loading.jl#L41-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="design/many_differentials.html">« Many Differential Types</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 7 February 2021 16:11">Sunday 7 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
