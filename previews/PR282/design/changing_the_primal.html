<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Changing the Primal · ChainRules</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/chainrules.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit">ChainRules</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="../FAQ.html">FAQ</a></li><li><a class="tocitem" href="../writing_good_rules.html">Writing Good Rules</a></li><li><a class="tocitem" href="../complex.html">Complex Numbers</a></li><li><a class="tocitem" href="../arrays.html">Deriving Array Rules</a></li><li><a class="tocitem" href="../debug_mode.html">Debug Mode</a></li><li><span class="tocitem">Usage in AD</span><ul><li><a class="tocitem" href="../autodiff/overview.html">Overview</a></li><li><a class="tocitem" href="../autodiff/operator_overloading.html">Operator Overloading</a></li></ul></li><li><span class="tocitem">Design</span><ul><li class="is-active"><a class="tocitem" href="changing_the_primal.html">Changing the Primal</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#TODO:"><span>TODO:</span></a></li></ul></li><li><a class="tocitem" href="many_differentials.html">Many Differential Types</a></li></ul></li><li><a class="tocitem" href="../api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Design</a></li><li class="is-active"><a href="changing_the_primal.html">Changing the Primal</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="changing_the_primal.html">Changing the Primal</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/design/changing_the_primal.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Design-Notes:-Why-can-you-change-the-primal?"><a class="docs-heading-anchor" href="#Design-Notes:-Why-can-you-change-the-primal?">Design Notes: Why can you change the primal?</a><a id="Design-Notes:-Why-can-you-change-the-primal?-1"></a><a class="docs-heading-anchor-permalink" href="#Design-Notes:-Why-can-you-change-the-primal?" title="Permalink"></a></h1><p>These design notes are to help you understand why ChainRules allows the primal computation, to be changed. We will focus this discussion on reverse mode and <code>rrule</code>, though the same also applies to forwards mode and <code>frule</code>. In fact, it has a particular use in forward mode for efficiently calculating the pushforward of a differential equation solve via expanding the system of equations to also include the derivatives, and solving all at once. In forward mode it is related to the fusing of <code>frule</code> and <code>pushforward</code>. In reverse mode we can focus on the the distinct primal and gradient passes.</p><p>Let&#39;s imagine a different system for rules, one that doesn&#39;t let you do this. This system is what a lot of AD systems have –- it is what <a href="https://github.com/invenia/Nabla.jl/">Nabla.jl</a><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> had originally. We will have a primal (i.e. forward) pass that directly executes the primal function and just records its <em>inputs</em> and its <em>output</em> (as well as the <em>primal function</em> itself) onto the tape.<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. Then during the gradient (i.e. reverse) pass it has a function which receives those records from the tape along with the sensitivity of the output, and gives back the sensitivity of the input. We will call this function <code>pullback_at</code>, as it pulls back the sensitivity at a given primal point. To make this concrete:</p><pre><code class="language-julia">y = f(x)  # primal program
x̄ = pullback_at(f, x, y, ȳ)</code></pre><p>Let&#39;s write one:</p><pre><code class="language-julia">y = sin(x)
pullback_at(::typeof(sin), x, y, ȳ) = ȳ * cos(x)</code></pre><p>Great. So far so good. As a short exercise the reader might like to implement the one for the <a href="https://en.wikipedia.org/wiki/Logistic_function#Derivative">logistic sigmoid</a>. It also works without issue.</p><p>Now let&#39;s consider why we implement <code>rrules</code> like this in the first place. One key reason, <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> is to allow us to insert our domain knowledge to do better than the AD would do just by breaking everything down into <code>+</code> and <code>*</code> etc. What insights do we have about <code>sin</code> and <code>cos</code>? Here is one:</p><pre><code class="language-julia">julia&gt; @btime sin(x) setup=(x=rand());
  3.838 ns (0 allocations: 0 bytes)

julia&gt; @btime cos(x) setup=(x=rand());
  4.795 ns (0 allocations: 0 bytes)

julia&gt; 3.838 + 4.795
8.633

julia&gt; @btime sincos(x) setup=(x=rand());
  6.028 ns (0 allocations: 0 bytes)</code></pre><p>It is \~30%<sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup> faster to compute <code>sin</code> and <code>cos</code> at the same time via <code>sincos</code> than it is to compute them one after the other. How can we incorporate this insight into our system? We know that we can compute the <code>cos(x)</code> at the same time as the <code>sin(x)</code> is computed in primal, because it only depends on <code>x</code> –- we don&#39;t need to know <code>ȳ</code>. but there is no-where to put it that is accessible both to the primal pass, and the gradient pass code.</p><p>What if we introduced some variable called <code>intermediates</code> that is also record onto the tape during the primal pass? We would need to be able to modify the primal pass to do this, so we can actually put the data into the <code>intermediates</code>. So we will introduce a function: <code>augmented_primal</code>, that will return the primal output, plus the <code>intermediates</code> that we want to reuse in the gradient pass. Then we will make our AD system replace calls to the primal with calls to the <code>augmented_primal</code> of the primal function; and take care of all the bookkeeping. So that would look like:</p><pre><code class="language-julia">y = f(x)  # primal program
y, intermediates = augmented_primal(f, x)
x̄ = pullback_at(f, x, y, ȳ, intermediates)</code></pre><p>Let&#39;s try writing this now:</p><pre><code class="language-julia">y = sin(x)
function augmented_primal(::typeof(sin), x)
  y, cx = sincos(x)
  return y, (; cx=cx)  # use a NamedTuple for the intermediates
end

pullback_at(::typeof(sin), x, y, ȳ, intermediates) = ȳ * intermediates.cx</code></pre><p>Cool! That lets us do what we wanted. We net deceased the time it takes to run the primal and gradient passes. We have now demostrated the title question of why we needed to be able to modify the primal pass. We will go into that more later, and have some more examples of use. But first lets continue to see how we go from that <code>augmented_primal</code> _ <code>pullback_at</code> to <a href="../api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>.</p><p>One thing we notice when looking at</p><h1 id="TODO:"><a class="docs-heading-anchor" href="#TODO:">TODO:</a><a id="TODO:-1"></a><a class="docs-heading-anchor-permalink" href="#TODO:" title="Permalink"></a></h1><ul><li>Highlight that there is a bunch of arguments to <code>pullback_at</code>.<ul><li>What if we wrapped them all up in a structure, like we did for <code>intermidates</code>?</li></ul></li><li>since <code>pullback_at</code> takes only 1 argument, other than <code>ȳ</code> so it would elegant if we make that struct callable, and had it do <code>pullback_at</code></li><li>It seems not geat that we are  including a bunch of things like the <code>output</code> and the <code>input</code> as well as <code>intermidiates</code>, why not treat them just like <code>intermidates</code> and only include the ones we are going to use?</li><li>Specifying them is kind of annoying, as is keeping them in-sync between <code>augmented_primal</code> and <code>pullback_at</code>.<ul><li>solve by making it a closure</li></ul></li></ul><p>Sure, this is small-fries and depending on julia version might just get solved by the optimizer<sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup>, but go with it for the sake of example.</p><p>To be precise this is very likely to be solved by the optimizer inlining both and then performing common subexpression elimination, with the result that it generates the code for <code>sincos</code> just form having <code>sin</code> and <code>cos</code> inside the same function.   However, this actually doesn&#39;t apply in the case of AD as it is not possible to inline code called in the gradient pass into the primal pass – those are seperate functions called at very different times.   This is something <a href="https://github.com/JuliaLang/julia/pull/37849">opaque closures</a> should help solve.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>I am not just picking on Nabla randomly. Many of the core developers of ChainRules worked on Nabla prior. It&#39;s a good AD, but ChainRules incorporates lessons learned from working on Nabla.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>which may be an explicit tape, or an implicit tape that is actually incorporated into generated code (ala Zygote)</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Another key reason is if the operations is a primitive that is not defined in terms of more basic operations. In many languages this is the case for <code>sin</code>; where the actual implementation is in some separate <code>libm.so</code>. But actually <a href="https://github.com/JuliaLang/julia/blob/caeaceff8af97565334f35309d812566183ec687/base/special/trig.jl"><code>sin</code> in Julia is defined in terms of a polynomial</a>. It&#39;s fairly vanilla julia code. It shouldn&#39;t be too hard for an AD that only knows about basic operations like <code>+</code> and <code>*</code> to AD through it. Though that will incur something that looks a lot like truncation error (in apparent violation of Griewank and Walther&#39;s 0th Rule of AD). In anycase, that is another discussion, for another day.</li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a></li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../autodiff/operator_overloading.html">« Operator Overloading</a><a class="docs-footer-nextpage" href="many_differentials.html">Many Differential Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 22 January 2021 11:24">Friday 22 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
