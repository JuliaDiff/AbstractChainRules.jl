<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gradient Accumulation · ChainRules</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit">ChainRules</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="FAQ.html">FAQ</a></li><li><a class="tocitem" href="config.html">Rule configurations and calling back into AD</a></li><li><a class="tocitem" href="opting_out_of_rules.html">Opting out of rules</a></li><li><a class="tocitem" href="writing_good_rules.html">Writing Good Rules</a></li><li><a class="tocitem" href="complex.html">Complex Numbers</a></li><li><a class="tocitem" href="arrays.html">Deriving Array Rules</a></li><li><a class="tocitem" href="debug_mode.html">Debug Mode</a></li><li class="is-active"><a class="tocitem" href="gradient_accumulation.html">Gradient Accumulation</a></li><li><a class="tocitem" href="use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="converting_zygoterules.html">Converting ZygoteRules</a></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="design/many_differentials.html">Many Differential Types</a></li></ul></li><li><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="gradient_accumulation.html">Gradient Accumulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="gradient_accumulation.html">Gradient Accumulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/gradient_accumulation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Gradient-Accumulation"><a class="docs-heading-anchor" href="#Gradient-Accumulation">Gradient Accumulation</a><a id="Gradient-Accumulation-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Accumulation" title="Permalink"></a></h1><p>Consider some function <span>$f(x) = g(x) + h(x)$</span>. If we would like the derivative of <span>$f$</span> with respect to <span>$x$</span> we must compute it for each part and then sum them, i.e. <span>$\frac{\partial f}{\partial x} = \frac{\partial g}{\partial x} + \frac{\partial h}{\partial x}$</span>. In general, we must accumulate (sum) gradients from each sub-part of a program where a variable is used.</p><p>Consider for example:</p><pre><code class="language-julia">function sum_first_and_second(X::Array{Float64})
    a = X[1]
    b = X[2]
    y = a + b
    return y
end</code></pre><p>The AD software must transform that into something which repeatedly sums up the gradient of each part: <code>X̄ = ā + b̄</code>.</p><p>This requires that all differential types <code>D</code> must implement <code>+</code>: <code>+(::D, ::D)::D</code>.</p><p>We can note that in this particular case <code>ā</code> and <code>b̄</code> will both be arrays. This operation (<code>X̄ = ā + b̄</code>) will allocate one array to hold <code>ā</code>, another one to hold <code>b̄</code>, and a third one to hold <code>ā + b̄</code>. This is three allocations. Allocations are not free, they increase the time the program takes to run by a nontrivial amount, even with a good allocator and a good garbage collector.</p><h3 id="Maybe-mutating-accumulation-(add!!)"><a class="docs-heading-anchor" href="#Maybe-mutating-accumulation-(add!!)">Maybe-mutating accumulation (<code>add!!</code>)</a><a id="Maybe-mutating-accumulation-(add!!)-1"></a><a class="docs-heading-anchor-permalink" href="#Maybe-mutating-accumulation-(add!!)" title="Permalink"></a></h3><p>We can note that in the above that neither <code>ā</code> nor <code>b̄</code> are ever used again after accumulating to get <code>X̄</code>. Furthermore, <code>Array</code>s are mutable. That means we could over-write either <code>ā</code> or <code>b̄</code> and use the result as <code>X̄</code>:</p><pre><code class="language-julia">ā .+= b̄
X̄ = ā</code></pre><p>This cuts our allocations down to 2, just <code>ā</code> and <code>b̄</code>.</p><p>However, we have a bit of a problem that not all types are mutable, so this pattern is hard to apply in general. To deal with that ChainRulesCore provides <a href="api.html#ChainRulesCore.add!!"><code>add!!</code></a>. Per the <a href="https://github.com/JuliaFolds/BangBang.jl">BangBang.jl</a> convention, this is a maybe mutating addition. It may mutate its first argument (if it is mutable), but it will definitely return the correct result. We would write using that as <code>X̄ = add!!(ā, b̄)</code>: which would in this case give us just 2 allocations. AD systems can generate <code>add!!</code> instead of <code>+</code> when accumulating gradient to take advantage of this.</p><h3 id="Inplaceable-Thunks-(InplaceableThunks)-avoid-allocating-values-in-the-first-place."><a class="docs-heading-anchor" href="#Inplaceable-Thunks-(InplaceableThunks)-avoid-allocating-values-in-the-first-place.">Inplaceable Thunks (<code>InplaceableThunks</code>) avoid allocating values in the first place.</a><a id="Inplaceable-Thunks-(InplaceableThunks)-avoid-allocating-values-in-the-first-place.-1"></a><a class="docs-heading-anchor-permalink" href="#Inplaceable-Thunks-(InplaceableThunks)-avoid-allocating-values-in-the-first-place." title="Permalink"></a></h3><p>We got down to two allocations from using <a href="api.html#ChainRulesCore.add!!"><code>add!!</code></a>, but can we do better? We can think of having a differential type which acts on a partially accumulated result, to mutate it to contain its current value plus the partial derivative being accumulated. Rather than having an actual computed value, we can just have a thing that will act on a value to perform the addition. Let&#39;s illustrate it with our example.</p><p><code>b̄</code> is the partial for <code>X[2]</code> and its value can be computed by:</p><pre><code class="language-julia">b̄ = zeros(size(X))
b̄[2] = ȳ  # the scalar sensitivity of the `sum_first_and_second` output</code></pre><p><code>b̄</code> is a matrix entirely of zeros, except for at the index <code>2</code>, where it is set to the output sensitivity <code>ȳ</code>. <code>ā</code> is similar, except with the non-zero at index <code>1</code>.</p><p>What is the action of <code>b̄</code> upon <code>ā</code>, to get the same result as <code>X̄ = add!!(ā, b̄)</code> (or <code>X̄ = ā + b̄</code> for that matter)? It is:</p><pre><code class="language-julia">function b̄_add!(ā)
    ā[2] += ȳ
    return ā
end</code></pre><p>We don&#39;t need to worry about all those zeros since <code>x + 0 == x</code>.</p><p><a href="api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a> is the type we have to represent derivatives as gradient accumulating actions. We must note that to do this we do need a value form of <code>ā</code> for <code>b̄</code> to act upon. For this reason every inplaceable thunk has both a <code>val</code> field holding the value representation, and a <code>add!</code> field holding the action representation. The <code>val</code> field use a plain <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> to avoid the computation (and thus allocation) if it is unused.</p><div class="admonition is-info"><header class="admonition-header">Do we need both representations?</header><div class="admonition-body"><p>Right now every <a href="api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a> has two fields that need to be specified. The value form (represented as a the <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> typed field), and the action form (represented as the <code>add!</code> field). It is possible in a future version of ChainRulesCore.jl we will work out a clever way to find the zero differential for arbitrary primal values. Given that, we could always just determine the value form from <code>inplaceable.add!(zero_differential(primal))</code>. There are some technical difficulties in finding the zero differentials, but this may be solved at some point.</p></div></div><p>The <code>+</code> operation on <code>InplaceableThunk</code>s is overloaded to <a href="api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a> that <code>val</code> field to get the value form. Where as the <a href="api.html#ChainRulesCore.add!!"><code>add!!</code></a> operation is overloaded to call <code>add!</code> to invoke the action.</p><p>With <code>getindex</code> defined to return an <code>InplaceableThunk</code>, we now get to <code>X̄ = add!!(ā, b̄)</code> requires only a single allocation. This allocation occurs when <code>unthunk</code>ing <code>ā</code>, which is then mutated to become <code>X̄</code>. This is basically as good as we can get: if we want <code>X̄</code> to be an <code>Array</code> then at some point we need to allocate that array.</p><div class="admonition is-info"><header class="admonition-header">Can we do more? Deferred accumulation</header><div class="admonition-body"><p>We could keep going further to drop allocations if we really wanted. If we didn&#39;t care about <code>X̄</code> being an <code>Array</code> then we could defer its computation too. <code>X̄ = @thunk add!!(ā, b̄)</code>. This kind of deferral will work fine and you can keep chaining it. It does start to burn stack space, and might make the compiler&#39;s optimization passes cry. But it&#39;s valid and should work fine.</p></div></div><h3 id="Examples-of-InplaceableThunks"><a class="docs-heading-anchor" href="#Examples-of-InplaceableThunks">Examples of InplaceableThunks</a><a id="Examples-of-InplaceableThunks-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-of-InplaceableThunks" title="Permalink"></a></h3><h4 id="getindex"><a class="docs-heading-anchor" href="#getindex"><code>getindex</code></a><a id="getindex-1"></a><a class="docs-heading-anchor-permalink" href="#getindex" title="Permalink"></a></h4><p>The aforementioned <code>getindex</code> is really the poster child for this. Consider something like:</p><pre><code class="language-julia">function mysum(X::Array{Float64})
    total = 0.0
    for i in eachindex(X)
        total += X[i]
    end
    return total
end</code></pre><p>If one only has value representation of derivatives one ends up having to allocate a derivative array for every single element of the original array <code>X</code>. That&#39;s terrible. On the other hand, with the action representation that <code>InplaceableThunk</code>s provide, there is just a single <code>Array</code> allocated. One can see <a href="https://github.com/JuliaDiff/ChainRules.jl/blob/v0.7.49/src/rulesets/Base/indexing.jl">the <code>getindex</code> rule in ChainRules.jl for the implementation</a>.</p><h4 id="matmul-etc-(*)"><a class="docs-heading-anchor" href="#matmul-etc-(*)">matmul etc (<code>*</code>)</a><a id="matmul-etc-(*)-1"></a><a class="docs-heading-anchor-permalink" href="#matmul-etc-(*)" title="Permalink"></a></h4><p>Multiplication of scalars/vectors/matrices of compatible dimensions can all also have their derivatives represented as an <code>InplaceableThunk</code>. These tend to pivot around that <code>add!</code> action being defined along the lines of: <code>X̄ -&gt; mul!(X̄, A&#39;, Ȳ, true, true)</code>. Where 5-arg <code>mul!</code> is the in place <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.mul!">multiply-add operation</a>. <code>mul!(X̄, A&#39;, Ȳ, true, true)</code> has the same effect as <code>(X̄ .+= A&#39;*Ȳ)</code> but avoids allocating  the matrix  <code>A&#39;*Ȳ</code> This is one of the fundamental operations provided by BLAS – including the application of the conjugate transpose. e.g. the Matrix-Matrix form is <a href="http://www.netlib.org/lapack/explore-html/d1/d54/group__double__blas__level3_gaeda3cbd99c8fb834a60a6412878226e1.html#gaeda3cbd99c8fb834a60a6412878226e1"><code>GEMM</code> (GEneralized Matrix-Matrix Multiplication)</a>, the Matrix-Vector form is <a href="http://www.netlib.org/lapack/explore-html/d7/d15/group__double__blas__level2_gadd421a107a488d524859b4a64c1901a9.html#gadd421a107a488d524859b4a64c1901a9"><code>GEMV</code> (GEneralized Matrix-Vector Multiplication)</a> etc. Under the hood doing it out of place is going to call one of these methods anyway, but on a freshly allocated output array. So we are going to hit a very efficient implementation and get the addition for free.</p><p>One can see <a href="https://github.com/JuliaDiff/ChainRules.jl/blob/v0.7.49/src/rulesets/Base/arraymath.jl#L22-L95">the <code>*</code> rules in ChainRules.jl for the implementations</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="debug_mode.html">« Debug Mode</a><a class="docs-footer-nextpage" href="use_in_ad_system.html">Usage in AD »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 28 August 2021 21:57">Saturday 28 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
